gunicorn.arbiter
================

.. py:module:: gunicorn.arbiter


Classes
-------

.. autoapisummary::

   gunicorn.arbiter.Arbiter


Module Contents
---------------

.. py:class:: Arbiter(app)

   Bases: :py:obj:`object`


   Arbiter maintain the workers processes alive. It launches or
   kills them if needed. It also manages application reloading
   via SIGHUP/USR2.


   .. py:attribute:: WORKER_BOOT_ERROR
      :value: 3



   .. py:attribute:: APP_LOAD_ERROR
      :value: 4



   .. py:attribute:: START_CTX


   .. py:attribute:: LISTENERS
      :value: []



   .. py:attribute:: WORKERS


   .. py:attribute:: PIPE
      :value: []



   .. py:attribute:: SIG_QUEUE
      :value: []



   .. py:attribute:: SIGNALS


   .. py:attribute:: SIG_NAMES


   .. py:attribute:: log
      :value: None



   .. py:attribute:: pidfile
      :value: None



   .. py:attribute:: systemd
      :value: False



   .. py:attribute:: worker_age
      :value: 0



   .. py:attribute:: reexec_pid
      :value: 0



   .. py:attribute:: master_pid
      :value: 0



   .. py:attribute:: master_name
      :value: 'Master'



   .. py:attribute:: num_workers


   .. py:method:: setup(app)


   .. py:method:: start()

      Initialize the arbiter. Start listening and set pidfile if needed.




   .. py:method:: init_signals()

      Initialize master signal handling. Most of the signals
      are queued. Child signals only wake up the master.



   .. py:method:: signal(sig, frame)


   .. py:method:: run()

      Main master loop.



   .. py:method:: handle_chld(sig, frame)

      SIGCHLD handling



   .. py:method:: handle_hup()

      HUP handling.
      - Reload configuration
      - Start the new worker processes with a new configuration
      - Gracefully shutdown the old worker processes



   .. py:method:: handle_term()

      SIGTERM handling



   .. py:method:: handle_int()

      SIGINT handling



   .. py:method:: handle_quit()

      SIGQUIT handling



   .. py:method:: handle_ttin()

      SIGTTIN handling.
      Increases the number of workers by one.



   .. py:method:: handle_ttou()

      SIGTTOU handling.
      Decreases the number of workers by one.



   .. py:method:: handle_usr1()

      SIGUSR1 handling.
      Kill all workers by sending them a SIGUSR1



   .. py:method:: handle_usr2()

      SIGUSR2 handling.
      Creates a new arbiter/worker set as a fork of the current
      arbiter without affecting old workers. Use this to do live
      deployment with the ability to backout a change.



   .. py:method:: handle_winch()

      SIGWINCH handling



   .. py:method:: maybe_promote_master()


   .. py:method:: wakeup()

      Wake up the arbiter by writing to the PIPE




   .. py:method:: halt(reason=None, exit_status=0)

      halt arbiter



   .. py:method:: sleep()

      Sleep until PIPE is readable or we timeout.
      A readable PIPE means a signal occurred.



   .. py:method:: stop(graceful=True)

      Stop workers

      :attr graceful: boolean, If True (the default) workers will be
      killed gracefully  (ie. trying to wait for the current connection)



   .. py:method:: reexec()

      Relaunch the master and workers.




   .. py:method:: reload()


   .. py:method:: murder_workers()

      Kill unused/idle workers




   .. py:method:: reap_workers()

      Reap workers to avoid zombie processes




   .. py:method:: manage_workers()

      Maintain the number of workers by spawning or killing
      as required.



   .. py:method:: spawn_worker()


   .. py:method:: spawn_workers()

      Spawn new workers as needed.

      This is where a worker process leaves the main loop
      of the master process.



   .. py:method:: kill_workers(sig)

      Kill all workers with the signal `sig`
      :attr sig: `signal.SIG*` value



   .. py:method:: kill_worker(pid, sig)

      Kill a worker

      :attr pid: int, worker pid
      :attr sig: `signal.SIG*` value




