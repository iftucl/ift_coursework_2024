gunicorn.workers.base
=====================

.. py:module:: gunicorn.workers.base


Classes
-------

.. autoapisummary::

   gunicorn.workers.base.Worker


Module Contents
---------------

.. py:class:: Worker(age, ppid, sockets, app, timeout, cfg, log)

   Bases: :py:obj:`object`


   .. py:attribute:: SIGNALS


   .. py:attribute:: PIPE
      :value: []



   .. py:attribute:: age


   .. py:attribute:: pid
      :value: '[booting]'



   .. py:attribute:: ppid


   .. py:attribute:: sockets


   .. py:attribute:: app


   .. py:attribute:: timeout


   .. py:attribute:: cfg


   .. py:attribute:: booted
      :value: False



   .. py:attribute:: aborted
      :value: False



   .. py:attribute:: reloader
      :value: None



   .. py:attribute:: nr
      :value: 0



   .. py:attribute:: alive
      :value: True



   .. py:attribute:: log


   .. py:attribute:: tmp


   .. py:method:: notify()

      Your worker subclass must arrange to have this method called
      once every ``self.timeout`` seconds. If you fail in accomplishing
      this task, the master process will murder your workers.



   .. py:method:: run()
      :abstractmethod:


      This is the mainloop of a worker process. You should override
      this method in a subclass to provide the intended behaviour
      for your particular evil schemes.



   .. py:method:: init_process()

      If you override this method in a subclass, the last statement
      in the function should be to call this method with
      super().init_process() so that the ``run()`` loop is initiated.



   .. py:method:: load_wsgi()


   .. py:method:: init_signals()


   .. py:method:: handle_usr1(sig, frame)


   .. py:method:: handle_exit(sig, frame)


   .. py:method:: handle_quit(sig, frame)


   .. py:method:: handle_abort(sig, frame)


   .. py:method:: handle_error(req, client, addr, exc)


   .. py:method:: handle_winch(sig, fname)


