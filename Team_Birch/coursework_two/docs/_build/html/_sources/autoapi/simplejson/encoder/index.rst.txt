simplejson.encoder
==================

.. py:module:: simplejson.encoder

.. autoapi-nested-parse::

   Implementation of JSONEncoder



Attributes
----------

.. autoapisummary::

   simplejson.encoder.ESCAPE
   simplejson.encoder.ESCAPE_ASCII
   simplejson.encoder.HAS_UTF8
   simplejson.encoder.ESCAPE_DCT
   simplejson.encoder.FLOAT_REPR
   simplejson.encoder.encode_basestring_ascii


Classes
-------

.. autoapisummary::

   simplejson.encoder.JSONEncoder
   simplejson.encoder.JSONEncoderForHTML


Functions
---------

.. autoapisummary::

   simplejson.encoder.encode_basestring
   simplejson.encoder.py_encode_basestring_ascii


Module Contents
---------------

.. py:data:: ESCAPE

.. py:data:: ESCAPE_ASCII

.. py:data:: HAS_UTF8

.. py:data:: ESCAPE_DCT

.. py:data:: FLOAT_REPR

.. py:function:: encode_basestring(s, _PY3=PY3, _q='"')

   Return a JSON representation of a Python string


.. py:function:: py_encode_basestring_ascii(s, _PY3=PY3)

   Return an ASCII-only JSON representation of a Python string


.. py:data:: encode_basestring_ascii

.. py:class:: JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=False, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, item_sort_key=None, for_json=False, ignore_nan=False, int_as_string_bitcount=None, iterable_as_array=False)

   Bases: :py:obj:`object`


   Extensible JSON <http://json.org> encoder for Python data structures.

   Supports the following objects and types by default:

   +-------------------+---------------+
   | Python            | JSON          |
   +===================+===============+
   | dict, namedtuple  | object        |
   +-------------------+---------------+
   | list, tuple       | array         |
   +-------------------+---------------+
   | str, unicode      | string        |
   +-------------------+---------------+
   | int, long, float  | number        |
   +-------------------+---------------+
   | True              | true          |
   +-------------------+---------------+
   | False             | false         |
   +-------------------+---------------+
   | None              | null          |
   +-------------------+---------------+

   To extend this to recognize other objects, subclass and implement a
   ``.default()`` method with another method that returns a serializable
   object for ``o`` if possible, otherwise it should call the superclass
   implementation (to raise ``TypeError``).



   .. py:attribute:: item_separator
      :value: ', '



   .. py:attribute:: key_separator
      :value: ': '



   .. py:attribute:: skipkeys
      :value: False



   .. py:attribute:: ensure_ascii
      :value: True



   .. py:attribute:: check_circular
      :value: True



   .. py:attribute:: allow_nan
      :value: False



   .. py:attribute:: sort_keys
      :value: False



   .. py:attribute:: use_decimal
      :value: True



   .. py:attribute:: namedtuple_as_object
      :value: True



   .. py:attribute:: tuple_as_array
      :value: True



   .. py:attribute:: iterable_as_array
      :value: False



   .. py:attribute:: bigint_as_string
      :value: False



   .. py:attribute:: item_sort_key
      :value: None



   .. py:attribute:: for_json
      :value: False



   .. py:attribute:: ignore_nan
      :value: False



   .. py:attribute:: int_as_string_bitcount
      :value: None



   .. py:attribute:: indent
      :value: None



   .. py:attribute:: encoding
      :value: 'utf-8'



   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              return JSONEncoder.default(self, o)




   .. py:method:: encode(o)

      Return a JSON string representation of a Python data structure.

      >>> from simplejson import JSONEncoder
      >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
      '{"foo": ["bar", "baz"]}'




   .. py:method:: iterencode(o)

      Encode the given object and yield each string
      representation as available.

      For example::

          for chunk in JSONEncoder().iterencode(bigobject):
              mysocket.write(chunk)




.. py:class:: JSONEncoderForHTML(skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=False, sort_keys=False, indent=None, separators=None, encoding='utf-8', default=None, use_decimal=True, namedtuple_as_object=True, tuple_as_array=True, bigint_as_string=False, item_sort_key=None, for_json=False, ignore_nan=False, int_as_string_bitcount=None, iterable_as_array=False)

   Bases: :py:obj:`JSONEncoder`


   An encoder that produces JSON safe to embed in HTML.

   To embed JSON content in, say, a script tag on a web page, the
   characters &, < and > should be escaped. They cannot be escaped
   with the usual entities (e.g. &amp;) because they are not expanded
   within <script> tags.

   This class also escapes the line separator and paragraph separator
   characters U+2028 and U+2029, irrespective of the ensure_ascii setting,
   as these characters are not valid in JavaScript strings (see
   http://timelessrepo.com/json-isnt-a-javascript-subset).


   .. py:method:: encode(o)

      Return a JSON string representation of a Python data structure.

      >>> from simplejson import JSONEncoder
      >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
      '{"foo": ["bar", "baz"]}'




   .. py:method:: iterencode(o)

      Encode the given object and yield each string
      representation as available.

      For example::

          for chunk in JSONEncoder().iterencode(bigobject):
              mysocket.write(chunk)




