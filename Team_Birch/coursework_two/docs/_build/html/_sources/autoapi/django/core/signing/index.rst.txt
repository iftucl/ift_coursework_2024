django.core.signing
===================

.. py:module:: django.core.signing

.. autoapi-nested-parse::

   Functions for creating and restoring url-safe signed JSON objects.

   The format used looks like this:

   >>> signing.dumps("hello")
   'ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk'

   There are two components here, separated by a ':'. The first component is a
   URLsafe base64 encoded JSON of the object passed to dumps(). The second
   component is a base64 encoded hmac/SHA-256 hash of "$first_component:$secret"

   signing.loads(s) checks the signature and returns the deserialized object.
   If the signature fails, a BadSignature exception is raised.

   >>> signing.loads("ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv422nZA4sgmk")
   'hello'
   >>> signing.loads("ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv42-modified")
   ...
   BadSignature: Signature "ImhlbGxvIg:1QaUZC:YIye-ze3TTx7gtSv42-modified" does not match

   You can optionally compress the JSON prior to base64 encoding it to save
   space, using the compress=True argument. This checks if compression actually
   helps and only applies compression if the result is a shorter string:

   >>> signing.dumps(list(range(1, 20)), compress=True)
   '.eJwFwcERACAIwLCF-rCiILN47r-GyZVJsNgkxaFxoDgxcOHGxMKD_T7vhAml:1QaUaL:BA0thEZrp4FQVXIXuOvYJtLJSrQ'

   The fact that the string is compressed is signalled by the prefixed '.' at the
   start of the base64 JSON.

   There are 65 url-safe characters: the 64 used by url-safe base64 and the ':'.
   These functions make use of all of them.



Attributes
----------

.. autoapisummary::

   django.core.signing.BASE62_ALPHABET


Exceptions
----------

.. autoapisummary::

   django.core.signing.BadSignature
   django.core.signing.SignatureExpired


Classes
-------

.. autoapisummary::

   django.core.signing.JSONSerializer
   django.core.signing.Signer
   django.core.signing.TimestampSigner


Functions
---------

.. autoapisummary::

   django.core.signing.b62_encode
   django.core.signing.b62_decode
   django.core.signing.b64_encode
   django.core.signing.b64_decode
   django.core.signing.base64_hmac
   django.core.signing.get_cookie_signer
   django.core.signing.dumps
   django.core.signing.loads


Module Contents
---------------

.. py:data:: BASE62_ALPHABET
   :value: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'


.. py:exception:: BadSignature

   Bases: :py:obj:`Exception`


   Signature does not match.


.. py:exception:: SignatureExpired

   Bases: :py:obj:`BadSignature`


   Signature timestamp is older than required max_age.


.. py:function:: b62_encode(s)

.. py:function:: b62_decode(s)

.. py:function:: b64_encode(s)

.. py:function:: b64_decode(s)

.. py:function:: base64_hmac(salt, value, key, algorithm='sha1')

.. py:function:: get_cookie_signer(salt='django.core.signing.get_cookie_signer')

.. py:class:: JSONSerializer

   Simple wrapper around json to be used in signing.dumps and
   signing.loads.


   .. py:method:: dumps(obj)


   .. py:method:: loads(data)


.. py:function:: dumps(obj, key=None, salt='django.core.signing', serializer=JSONSerializer, compress=False)

   Return URL-safe, hmac signed base64 compressed JSON string. If key is
   None, use settings.SECRET_KEY instead. The hmac algorithm is the default
   Signer algorithm.

   If compress is True (not the default), check if compressing using zlib can
   save some space. Prepend a '.' to signify compression. This is included
   in the signature, to protect against zip bombs.

   Salt can be used to namespace the hash, so that a signed string is
   only valid for a given namespace. Leaving this at the default
   value or re-using a salt value across different parts of your
   application without good cause is a security risk.

   The serializer is expected to return a bytestring.


.. py:function:: loads(s, key=None, salt='django.core.signing', serializer=JSONSerializer, max_age=None, fallback_keys=None)

   Reverse of dumps(), raise BadSignature if signature fails.

   The serializer is expected to accept a bytestring.


.. py:class:: Signer(*args, key=None, sep=':', salt=None, algorithm=None, fallback_keys=None)

   .. py:attribute:: key


   .. py:attribute:: fallback_keys
      :value: None



   .. py:attribute:: sep
      :value: ':'



   .. py:attribute:: salt
      :value: 'Unknown.str'



   .. py:attribute:: algorithm
      :value: 'sha256'



   .. py:method:: signature(value, key=None)


   .. py:method:: sign(value)


   .. py:method:: unsign(signed_value)


   .. py:method:: sign_object(obj, serializer=JSONSerializer, compress=False)

      Return URL-safe, hmac signed base64 compressed JSON string.

      If compress is True (not the default), check if compressing using zlib
      can save some space. Prepend a '.' to signify compression. This is
      included in the signature, to protect against zip bombs.

      The serializer is expected to return a bytestring.



   .. py:method:: unsign_object(signed_obj, serializer=JSONSerializer, **kwargs)


.. py:class:: TimestampSigner(*args, key=None, sep=':', salt=None, algorithm=None, fallback_keys=None)

   Bases: :py:obj:`Signer`


   .. py:method:: timestamp()


   .. py:method:: sign(value)


   .. py:method:: unsign(value, max_age=None)

      Retrieve original value and check it wasn't signed more
      than max_age seconds ago.



