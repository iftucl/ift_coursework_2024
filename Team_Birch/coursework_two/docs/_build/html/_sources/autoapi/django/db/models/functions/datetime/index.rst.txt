django.db.models.functions.datetime
===================================

.. py:module:: django.db.models.functions.datetime


Classes
-------

.. autoapisummary::

   django.db.models.functions.datetime.TimezoneMixin
   django.db.models.functions.datetime.Extract
   django.db.models.functions.datetime.ExtractYear
   django.db.models.functions.datetime.ExtractIsoYear
   django.db.models.functions.datetime.ExtractMonth
   django.db.models.functions.datetime.ExtractDay
   django.db.models.functions.datetime.ExtractWeek
   django.db.models.functions.datetime.ExtractWeekDay
   django.db.models.functions.datetime.ExtractIsoWeekDay
   django.db.models.functions.datetime.ExtractQuarter
   django.db.models.functions.datetime.ExtractHour
   django.db.models.functions.datetime.ExtractMinute
   django.db.models.functions.datetime.ExtractSecond
   django.db.models.functions.datetime.Now
   django.db.models.functions.datetime.TruncBase
   django.db.models.functions.datetime.Trunc
   django.db.models.functions.datetime.TruncYear
   django.db.models.functions.datetime.TruncQuarter
   django.db.models.functions.datetime.TruncMonth
   django.db.models.functions.datetime.TruncWeek
   django.db.models.functions.datetime.TruncDay
   django.db.models.functions.datetime.TruncDate
   django.db.models.functions.datetime.TruncTime
   django.db.models.functions.datetime.TruncHour
   django.db.models.functions.datetime.TruncMinute
   django.db.models.functions.datetime.TruncSecond


Module Contents
---------------

.. py:class:: TimezoneMixin

   .. py:attribute:: tzinfo
      :value: None



   .. py:method:: get_tzname()


.. py:class:: Extract(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`TimezoneMixin`, :py:obj:`django.db.models.lookups.Transform`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: None



   .. py:attribute:: output_field

      Return the output type of this expressions.


   .. py:attribute:: tzinfo
      :value: None



   .. py:method:: as_sql(compiler, connection)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



   .. py:method:: resolve_expression(query=None, allow_joins=True, reuse=None, summarize=False, for_save=False)

      Provide the chance to do any preprocessing or validation before being
      added to the query.

      :param \* query: the backend query implementation
      :param \* allow_joins: boolean allowing or denying use of joins
                             in this query
      :param \* reuse: a set of reusable joins for multijoins
      :param \* summarize: a terminal aggregate clause
      :param \* for_save: whether this expression about to be used in a save or update

      Return: an Expression to be added to the query.



.. py:class:: ExtractYear(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'year'



.. py:class:: ExtractIsoYear(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   Return the ISO-8601 week-numbering year.


   .. py:attribute:: lookup_name
      :value: 'iso_year'



.. py:class:: ExtractMonth(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'month'



.. py:class:: ExtractDay(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'day'



.. py:class:: ExtractWeek(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   Return 1-52 or 53, based on ISO-8601, i.e., Monday is the first of the
   week.


   .. py:attribute:: lookup_name
      :value: 'week'



.. py:class:: ExtractWeekDay(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   Return Sunday=1 through Saturday=7.

   To replicate this in Python: (mydatetime.isoweekday() % 7) + 1


   .. py:attribute:: lookup_name
      :value: 'week_day'



.. py:class:: ExtractIsoWeekDay(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   Return Monday=1 through Sunday=7, based on ISO-8601.


   .. py:attribute:: lookup_name
      :value: 'iso_week_day'



.. py:class:: ExtractQuarter(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'quarter'



.. py:class:: ExtractHour(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'hour'



.. py:class:: ExtractMinute(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'minute'



.. py:class:: ExtractSecond(expression, lookup_name=None, tzinfo=None, **extra)

   Bases: :py:obj:`Extract`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: lookup_name
      :value: 'second'



.. py:class:: Now(*expressions, output_field=None, **extra)

   Bases: :py:obj:`django.db.models.expressions.Func`


   An SQL function call.


   .. py:attribute:: template
      :value: 'CURRENT_TIMESTAMP'



   .. py:attribute:: output_field

      Return the output type of this expressions.


   .. py:method:: as_postgresql(compiler, connection, **extra_context)


   .. py:method:: as_mysql(compiler, connection, **extra_context)


   .. py:method:: as_sqlite(compiler, connection, **extra_context)


.. py:class:: TruncBase(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TimezoneMixin`, :py:obj:`django.db.models.lookups.Transform`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: None



   .. py:attribute:: tzinfo
      :value: None



   .. py:attribute:: is_dst


   .. py:method:: as_sql(compiler, connection)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



   .. py:method:: resolve_expression(query=None, allow_joins=True, reuse=None, summarize=False, for_save=False)

      Provide the chance to do any preprocessing or validation before being
      added to the query.

      :param \* query: the backend query implementation
      :param \* allow_joins: boolean allowing or denying use of joins
                             in this query
      :param \* reuse: a set of reusable joins for multijoins
      :param \* summarize: a terminal aggregate clause
      :param \* for_save: whether this expression about to be used in a save or update

      Return: an Expression to be added to the query.



   .. py:method:: convert_value(value, expression, connection)

      Expressions provide their own converters because users have the option
      of manually specifying the output_field which may be a different type
      from the one the database returns.



.. py:class:: Trunc(expression, kind, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind


.. py:class:: TruncYear(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'year'



.. py:class:: TruncQuarter(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'quarter'



.. py:class:: TruncMonth(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'month'



.. py:class:: TruncWeek(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   Truncate to midnight on the Monday of the week.


   .. py:attribute:: kind
      :value: 'week'



.. py:class:: TruncDay(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'day'



.. py:class:: TruncDate(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'date'



   .. py:attribute:: lookup_name
      :value: 'date'



   .. py:attribute:: output_field

      Return the output type of this expressions.


   .. py:method:: as_sql(compiler, connection)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



.. py:class:: TruncTime(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'time'



   .. py:attribute:: lookup_name
      :value: 'time'



   .. py:attribute:: output_field

      Return the output type of this expressions.


   .. py:method:: as_sql(compiler, connection)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



.. py:class:: TruncHour(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'hour'



.. py:class:: TruncMinute(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'minute'



.. py:class:: TruncSecond(expression, output_field=None, tzinfo=None, is_dst=timezone.NOT_PASSED, **extra)

   Bases: :py:obj:`TruncBase`


   RegisterLookupMixin() is first so that get_lookup() and get_transform()
   first examine self and then check output_field.


   .. py:attribute:: kind
      :value: 'second'



