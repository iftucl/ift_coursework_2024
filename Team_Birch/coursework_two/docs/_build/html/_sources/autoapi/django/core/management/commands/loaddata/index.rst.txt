django.core.management.commands.loaddata
========================================

.. py:module:: django.core.management.commands.loaddata


Attributes
----------

.. autoapisummary::

   django.core.management.commands.loaddata.has_bz2
   django.core.management.commands.loaddata.has_lzma
   django.core.management.commands.loaddata.READ_STDIN


Classes
-------

.. autoapisummary::

   django.core.management.commands.loaddata.Command
   django.core.management.commands.loaddata.SingleZipReader


Functions
---------

.. autoapisummary::

   django.core.management.commands.loaddata.humanize


Module Contents
---------------

.. py:data:: has_bz2
   :value: True


.. py:data:: has_lzma
   :value: True


.. py:data:: READ_STDIN
   :value: '-'


.. py:class:: Command(stdout=None, stderr=None, no_color=False, force_color=False)

   Bases: :py:obj:`django.core.management.base.BaseCommand`


   The base class from which all management commands ultimately
   derive.

   Use this class if you want access to all of the mechanisms which
   parse the command-line arguments and work out what code to call in
   response; if you don't need to change any of that behavior,
   consider using one of the subclasses defined in this file.

   If you are interested in overriding/customizing various aspects of
   the command-parsing and -execution behavior, the normal flow works
   as follows:

   1. ``django-admin`` or ``manage.py`` loads the command class
      and calls its ``run_from_argv()`` method.

   2. The ``run_from_argv()`` method calls ``create_parser()`` to get
      an ``ArgumentParser`` for the arguments, parses them, performs
      any environment changes requested by options like
      ``pythonpath``, and then calls the ``execute()`` method,
      passing the parsed arguments.

   3. The ``execute()`` method attempts to carry out the command by
      calling the ``handle()`` method with the parsed arguments; any
      output produced by ``handle()`` will be printed to standard
      output and, if the command is intended to produce a block of
      SQL statements, will be wrapped in ``BEGIN`` and ``COMMIT``.

   4. If ``handle()`` or ``execute()`` raised any exception (e.g.
      ``CommandError``), ``run_from_argv()`` will  instead print an error
      message to ``stderr``.

   Thus, the ``handle()`` method is typically the starting point for
   subclasses; many built-in commands and command types either place
   all of their logic in ``handle()``, or perform some additional
   parsing work in ``handle()`` and then delegate from it to more
   specialized methods as needed.

   Several attributes affect behavior at various steps along the way:

   ``help``
       A short description of the command, which will be printed in
       help messages.

   ``output_transaction``
       A boolean indicating whether the command outputs SQL
       statements; if ``True``, the output will automatically be
       wrapped with ``BEGIN;`` and ``COMMIT;``. Default value is
       ``False``.

   ``requires_migrations_checks``
       A boolean; if ``True``, the command prints a warning if the set of
       migrations on disk don't match the migrations in the database.

   ``requires_system_checks``
       A list or tuple of tags, e.g. [Tags.staticfiles, Tags.models]. System
       checks registered in the chosen tags will be checked for errors prior
       to executing the command. The value '__all__' can be used to specify
       that all system checks should be performed. Default value is '__all__'.

       To validate an individual application's models
       rather than all applications' models, call
       ``self.check(app_configs)`` from ``handle()``, where ``app_configs``
       is the list of application's configuration provided by the
       app registry.

   ``stealth_options``
       A tuple of any options the command uses which aren't defined by the
       argument parser.


   .. py:attribute:: help
      :value: 'Installs the named fixture(s) in the database.'



   .. py:attribute:: missing_args_message
      :value: 'No database fixture specified. Please provide the path of at least one fixture in the command line.'



   .. py:method:: add_arguments(parser)

      Entry point for subclassed commands to add custom arguments.



   .. py:method:: handle(*fixture_labels, **options)

      The actual logic of the command. Subclasses must implement
      this method.



   .. py:method:: compression_formats()

      A dict mapping format names to (open function, mode arg) tuples.



   .. py:method:: reset_sequences(connection, models)

      Reset database sequences for the given connection and models.



   .. py:method:: loaddata(fixture_labels)


   .. py:method:: save_obj(obj)

      Save an object if permitted.



   .. py:method:: load_label(fixture_label)

      Load fixtures files for a given label.



   .. py:method:: get_fixture_name_and_dirs(fixture_name)


   .. py:method:: get_targets(fixture_name, ser_fmt, cmp_fmt)


   .. py:method:: find_fixture_files_in_dir(fixture_dir, fixture_name, targets)


   .. py:method:: find_fixtures(fixture_label)

      Find fixture files for a given label.



   .. py:method:: fixture_dirs()

      Return a list of fixture directories.

      The list contains the 'fixtures' subdirectory of each installed
      application, if it exists, the directories in FIXTURE_DIRS, and the
      current directory.



   .. py:method:: parse_name(fixture_name)

      Split fixture name in name, serialization format, compression format.



.. py:class:: SingleZipReader(*args, **kwargs)

   Bases: :py:obj:`zipfile.ZipFile`


   Class with methods to open, read, write, close, list zip files.

   z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
               compresslevel=None)

   file: Either the path to the file, or a file-like object.
         If it is a path, the file will be opened and closed by ZipFile.
   mode: The mode can be either read 'r', write 'w', exclusive create 'x',
         or append 'a'.
   compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
                ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
   allowZip64: if True ZipFile will create files with ZIP64 extensions when
               needed, otherwise it will raise an exception when this would
               be necessary.
   compresslevel: None (default for the given compression type) or an integer
                  specifying the level to pass to the compressor.
                  When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
                  When using ZIP_DEFLATED integers 0 through 9 are accepted.
                  When using ZIP_BZIP2 integers 1 through 9 are accepted.



   .. py:method:: read()

      Return file bytes for name. 'pwd' is the password to decrypt
      encrypted files.



.. py:function:: humanize(dirname)

