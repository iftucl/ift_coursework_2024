django.utils.crypto
===================

.. py:module:: django.utils.crypto

.. autoapi-nested-parse::

   Django's standard crypto functions and utilities.



Attributes
----------

.. autoapisummary::

   django.utils.crypto.RANDOM_STRING_CHARS
   django.utils.crypto.md5


Exceptions
----------

.. autoapisummary::

   django.utils.crypto.InvalidAlgorithm


Functions
---------

.. autoapisummary::

   django.utils.crypto.salted_hmac
   django.utils.crypto.get_random_string
   django.utils.crypto.constant_time_compare
   django.utils.crypto.pbkdf2


Module Contents
---------------

.. py:exception:: InvalidAlgorithm

   Bases: :py:obj:`ValueError`


   Algorithm is not supported by hashlib.


.. py:function:: salted_hmac(key_salt, value, secret=None, *, algorithm='sha1')

   Return the HMAC of 'value', using a key generated from key_salt and a
   secret (which defaults to settings.SECRET_KEY). Default algorithm is SHA1,
   but any algorithm name supported by hashlib can be passed.

   A different key_salt should be passed in for every application of HMAC.


.. py:data:: RANDOM_STRING_CHARS
   :value: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'


.. py:function:: get_random_string(length, allowed_chars=RANDOM_STRING_CHARS)

   Return a securely generated random string.

   The bit length of the returned value can be calculated with the formula:
       log_2(len(allowed_chars)^length)

   For example, with default `allowed_chars` (26+26+10), this gives:
     * length: 12, bit length =~ 71 bits
     * length: 22, bit length =~ 131 bits


.. py:function:: constant_time_compare(val1, val2)

   Return True if the two strings are equal, False otherwise.


.. py:function:: pbkdf2(password, salt, iterations, dklen=0, digest=None)

   Return the hash of password using pbkdf2.


.. py:data:: md5

