django.db.models.fields
=======================

.. py:module:: django.db.models.fields


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/django/db/models/fields/files/index
   /autoapi/django/db/models/fields/json/index
   /autoapi/django/db/models/fields/mixins/index
   /autoapi/django/db/models/fields/proxy/index
   /autoapi/django/db/models/fields/related/index
   /autoapi/django/db/models/fields/related_descriptors/index
   /autoapi/django/db/models/fields/related_lookups/index
   /autoapi/django/db/models/fields/reverse_related/index


Attributes
----------

.. autoapisummary::

   django.db.models.fields.BLANK_CHOICE_DASH


Classes
-------

.. autoapisummary::

   django.db.models.fields.Empty
   django.db.models.fields.NOT_PROVIDED
   django.db.models.fields.Field
   django.db.models.fields.BooleanField
   django.db.models.fields.CharField
   django.db.models.fields.CommaSeparatedIntegerField
   django.db.models.fields.DateField
   django.db.models.fields.DateTimeField
   django.db.models.fields.DecimalField
   django.db.models.fields.DurationField
   django.db.models.fields.EmailField
   django.db.models.fields.FilePathField
   django.db.models.fields.FloatField
   django.db.models.fields.IntegerField
   django.db.models.fields.BigIntegerField
   django.db.models.fields.SmallIntegerField
   django.db.models.fields.IPAddressField
   django.db.models.fields.GenericIPAddressField
   django.db.models.fields.NullBooleanField
   django.db.models.fields.PositiveBigIntegerField
   django.db.models.fields.PositiveIntegerField
   django.db.models.fields.PositiveSmallIntegerField
   django.db.models.fields.SlugField
   django.db.models.fields.TextField
   django.db.models.fields.TimeField
   django.db.models.fields.URLField
   django.db.models.fields.BinaryField
   django.db.models.fields.UUIDField
   django.db.models.fields.AutoField
   django.db.models.fields.BigAutoField
   django.db.models.fields.SmallAutoField


Package Contents
----------------

.. py:class:: Empty

.. py:class:: NOT_PROVIDED

.. py:data:: BLANK_CHOICE_DASH
   :value: [('', '---------')]


.. py:class:: Field(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`django.db.models.query_utils.RegisterLookupMixin`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: True



   .. py:attribute:: empty_values


   .. py:attribute:: creation_counter
      :value: 0



   .. py:attribute:: auto_creation_counter
      :value: -1



   .. py:attribute:: default_validators
      :value: []



   .. py:attribute:: default_error_messages


   .. py:attribute:: system_check_deprecated_details
      :value: None



   .. py:attribute:: system_check_removed_details
      :value: None



   .. py:attribute:: non_db_attrs
      :value: ('blank', 'choices', 'db_column', 'editable', 'error_messages', 'help_text', 'limit_choices_to',...



   .. py:attribute:: hidden
      :value: False



   .. py:attribute:: many_to_many
      :value: None



   .. py:attribute:: many_to_one
      :value: None



   .. py:attribute:: one_to_many
      :value: None



   .. py:attribute:: one_to_one
      :value: None



   .. py:attribute:: related_model
      :value: None



   .. py:attribute:: descriptor_class


   .. py:attribute:: description


   .. py:attribute:: name
      :value: None



   .. py:attribute:: verbose_name
      :value: None



   .. py:attribute:: primary_key
      :value: False



   .. py:attribute:: remote_field
      :value: None



   .. py:attribute:: is_relation


   .. py:attribute:: default


   .. py:attribute:: editable
      :value: True



   .. py:attribute:: serialize
      :value: True



   .. py:attribute:: unique_for_date
      :value: None



   .. py:attribute:: unique_for_month
      :value: None



   .. py:attribute:: unique_for_year
      :value: None



   .. py:attribute:: choices
      :value: None



   .. py:attribute:: help_text
      :value: ''



   .. py:attribute:: db_index
      :value: False



   .. py:attribute:: db_column
      :value: None



   .. py:attribute:: db_comment
      :value: None



   .. py:attribute:: auto_created
      :value: False



   .. py:method:: check(**kwargs)


   .. py:method:: get_col(alias, output_field=None)


   .. py:method:: cached_col()


   .. py:method:: select_format(compiler, sql, params)

      Custom format for select clauses. For example, GIS columns need to be
      selected as AsText(table.col) on MySQL as the table.col data can't be
      used by Django.



   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: clone()

      Uses deconstruct() to clone a new copy of this Field.
      Will not preserve any class attachments/attribute names.



   .. py:method:: get_pk_value_on_save(instance)

      Hook to generate new PK values on save. This method is called when
      saving instances with no primary key value set. If this method returns
      something else than None, then the returned value is used when saving
      the new instance.



   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: error_messages()


   .. py:method:: validators()

      Some validators can't be created at field initialization time.
      This method provides a way to delay their creation until required.



   .. py:method:: run_validators(value)


   .. py:method:: validate(value, model_instance)

      Validate value and raise ValidationError if necessary. Subclasses
      should override this to provide validation logic.



   .. py:method:: clean(value, model_instance)

      Convert the value's type and run validation. Validation errors
      from to_python() and validate() are propagated. Return the correct
      value if no error is raised.



   .. py:method:: db_type_parameters(connection)


   .. py:method:: db_check(connection)

      Return the database column check constraint for this field, for the
      provided connection. Works the same way as db_type() for the case that
      get_internal_type() does not map to a preexisting model field.



   .. py:method:: db_type(connection)

      Return the database column data type for this field, for the provided
      connection.



   .. py:method:: rel_db_type(connection)

      Return the data type that a related field pointing to this field should
      use. For example, this method is called by ForeignKey and OneToOneField
      to determine its data type.



   .. py:method:: cast_db_type(connection)

      Return the data type to use in the Cast() function.



   .. py:method:: db_parameters(connection)

      Extension of db_type(), providing a range of different return values
      (type, checks). This will look at db_type(), allowing custom model
      fields to override it.



   .. py:method:: db_type_suffix(connection)


   .. py:method:: get_db_converters(connection)


   .. py:property:: unique


   .. py:property:: db_tablespace


   .. py:property:: db_returning

      Private API intended only to be used by Django itself. Currently only
      the PostgreSQL backend supports returning multiple fields on a model.


   .. py:method:: set_attributes_from_name(name)


   .. py:method:: contribute_to_class(cls, name, private_only=False)

      Register the field with the model class it belongs to.

      If private_only is True, create a separate instance of this field
      for every subclass of cls, even if cls is not an abstract model.



   .. py:method:: get_filter_kwargs_for_object(obj)

      Return a dict that when passed as kwargs to self.model.filter(), would
      yield all instances having the same value for this field as obj has.



   .. py:method:: get_attname()


   .. py:method:: get_attname_column()


   .. py:method:: get_internal_type()


   .. py:method:: pre_save(model_instance, add)

      Return field's value just before saving.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: get_db_prep_save(value, connection)

      Return field's value prepared for saving into a database.



   .. py:method:: has_default()

      Return a boolean of whether this field has a default value.



   .. py:method:: get_default()

      Return the default value for this field.



   .. py:method:: get_choices(include_blank=True, blank_choice=BLANK_CHOICE_DASH, limit_choices_to=None, ordering=())

      Return choices with a default blank choices included, for use
      as <select> choices for this field.



   .. py:method:: value_to_string(obj)

      Return a string value of this field from the passed obj.
      This is used by the serialization framework.



   .. py:attribute:: flatchoices


   .. py:method:: save_form_data(instance, data)


   .. py:method:: formfield(form_class=None, choices_form_class=None, **kwargs)

      Return a django.forms.Field instance for this field.



   .. py:method:: value_from_object(obj)

      Return the value of this field in the given model instance.



.. py:class:: BooleanField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: CharField(*args, db_collation=None, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: db_collation
      :value: None



   .. py:property:: description


   .. py:method:: check(**kwargs)


   .. py:method:: cast_db_type(connection)

      Return the data type to use in the Cast() function.



   .. py:method:: db_parameters(connection)

      Extension of db_type(), providing a range of different return values
      (type, checks). This will look at db_type(), allowing custom model
      fields to override it.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



.. py:class:: CommaSeparatedIntegerField(*args, db_collation=None, **kwargs)

   Bases: :py:obj:`CharField`


   Base class for all field types


   .. py:attribute:: default_validators


   .. py:attribute:: description


   .. py:attribute:: system_check_removed_details


.. py:class:: DateField(verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs)

   Bases: :py:obj:`DateTimeCheckMixin`, :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: pre_save(model_instance, add)

      Return field's value just before saving.



   .. py:method:: contribute_to_class(cls, name, **kwargs)

      Register the field with the model class it belongs to.

      If private_only is True, create a separate instance of this field
      for every subclass of cls, even if cls is not an abstract model.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: value_to_string(obj)

      Return a string value of this field from the passed obj.
      This is used by the serialization framework.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: DateTimeField(verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs)

   Bases: :py:obj:`DateField`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: pre_save(model_instance, add)

      Return field's value just before saving.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: value_to_string(obj)

      Return a string value of this field from the passed obj.
      This is used by the serialization framework.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: DecimalField(verbose_name=None, name=None, max_digits=None, decimal_places=None, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: check(**kwargs)


   .. py:method:: validators()

      Some validators can't be created at field initialization time.
      This method provides a way to delay their creation until required.



   .. py:method:: context()


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: get_db_prep_save(value, connection)

      Return field's value prepared for saving into a database.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: DurationField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`Field`


   Store timedelta objects.

   Use interval on PostgreSQL, INTERVAL DAY TO SECOND on Oracle, and bigint
   of microseconds on other databases.


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: get_db_converters(connection)


   .. py:method:: value_to_string(obj)

      Return a string value of this field from the passed obj.
      This is used by the serialization framework.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: EmailField(*args, **kwargs)

   Bases: :py:obj:`CharField`


   Base class for all field types


   .. py:attribute:: default_validators


   .. py:attribute:: description


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: FilePathField(verbose_name=None, name=None, path='', match=None, recursive=False, allow_files=True, allow_folders=False, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: description


   .. py:method:: check(**kwargs)


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



   .. py:method:: get_internal_type()


.. py:class:: FloatField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: IntegerField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: check(**kwargs)


   .. py:method:: validators()

      Some validators can't be created at field initialization time.
      This method provides a way to delay their creation until required.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: BigIntegerField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`IntegerField`


   Base class for all field types


   .. py:attribute:: description


   .. py:attribute:: MAX_BIGINT
      :value: 9223372036854775807



   .. py:method:: get_internal_type()


   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: SmallIntegerField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`IntegerField`


   Base class for all field types


   .. py:attribute:: description


   .. py:method:: get_internal_type()


.. py:class:: IPAddressField(*args, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: description


   .. py:attribute:: system_check_removed_details


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_internal_type()


.. py:class:: GenericIPAddressField(verbose_name=None, name=None, protocol='both', unpack_ipv4=False, *args, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: description


   .. py:attribute:: default_error_messages


   .. py:attribute:: unpack_ipv4
      :value: False



   .. py:attribute:: protocol
      :value: 'both'



   .. py:method:: check(**kwargs)


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: NullBooleanField(*args, **kwargs)

   Bases: :py:obj:`BooleanField`


   Base class for all field types


   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:attribute:: system_check_removed_details


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



.. py:class:: PositiveBigIntegerField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`PositiveIntegerRelDbTypeMixin`, :py:obj:`BigIntegerField`


   Base class for all field types


   .. py:attribute:: description


   .. py:method:: get_internal_type()


   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: PositiveIntegerField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`PositiveIntegerRelDbTypeMixin`, :py:obj:`IntegerField`


   Base class for all field types


   .. py:attribute:: description


   .. py:method:: get_internal_type()


   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: PositiveSmallIntegerField(verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None, db_comment=None)

   Bases: :py:obj:`PositiveIntegerRelDbTypeMixin`, :py:obj:`SmallIntegerField`


   Base class for all field types


   .. py:attribute:: description


   .. py:method:: get_internal_type()


   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: SlugField(*args, max_length=50, db_index=True, allow_unicode=False, **kwargs)

   Bases: :py:obj:`CharField`


   Base class for all field types


   .. py:attribute:: default_validators


   .. py:attribute:: description


   .. py:attribute:: allow_unicode
      :value: False



   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: TextField(*args, db_collation=None, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: description


   .. py:attribute:: db_collation
      :value: None



   .. py:method:: check(**kwargs)


   .. py:method:: db_parameters(connection)

      Extension of db_type(), providing a range of different return values
      (type, checks). This will look at db_type(), allowing custom model
      fields to override it.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



.. py:class:: TimeField(verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs)

   Bases: :py:obj:`DateTimeCheckMixin`, :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: pre_save(model_instance, add)

      Return field's value just before saving.



   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: value_to_string(obj)

      Return a string value of this field from the passed obj.
      This is used by the serialization framework.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: URLField(verbose_name=None, name=None, **kwargs)

   Bases: :py:obj:`CharField`


   Base class for all field types


   .. py:attribute:: default_validators


   .. py:attribute:: description


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: BinaryField(*args, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: description


   .. py:attribute:: empty_values
      :value: [None, b'']



   .. py:method:: check(**kwargs)


   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: get_placeholder(value, compiler, connection)


   .. py:method:: get_default()

      Return the default value for this field.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: value_to_string(obj)

      Binary data is serialized as base64



   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



.. py:class:: UUIDField(verbose_name=None, **kwargs)

   Bases: :py:obj:`Field`


   Base class for all field types


   .. py:attribute:: default_error_messages


   .. py:attribute:: description


   .. py:attribute:: empty_strings_allowed
      :value: False



   .. py:method:: deconstruct()

      Return enough information to recreate the field as a 4-tuple:

       * The name of the field on the model, if contribute_to_class() has
         been run.
       * The import path of the field, including the class, e.g.
         django.db.models.IntegerField. This should be the most portable
         version, so less specific may be better.
       * A list of positional arguments.
       * A dict of keyword arguments.

      Note that the positional or keyword arguments must contain values of
      the following types (including inner values of collection types):

       * None, bool, str, int, float, complex, set, frozenset, list, tuple,
         dict
       * UUID
       * datetime.datetime (naive), datetime.date
       * top-level classes, top-level functions - will be referenced by their
         full import path
       * Storage instances - these have their own deconstruct() method

      This is because the values here must be serialized into a text format
      (possibly new Python code, possibly JSON) and these are the only types
      with encoding handlers defined.

      There's no need to return the exact way the field was instantiated this
      time, just ensure that the resulting field is the same - prefer keyword
      arguments over positional ones, and omit parameters with their default
      values.



   .. py:method:: get_internal_type()


   .. py:method:: get_prep_value(value)

      Perform preliminary non-db specific value checks and conversions.



   .. py:method:: get_db_prep_value(value, connection, prepared=False)

      Return field's value prepared for interacting with the database backend.

      Used by the default implementations of get_db_prep_save().



   .. py:method:: to_python(value)

      Convert the input value into the expected Python data type, raising
      django.core.exceptions.ValidationError if the data can't be converted.
      Return the converted value. Subclasses should override this.



   .. py:method:: formfield(**kwargs)

      Return a django.forms.Field instance for this field.



.. py:class:: AutoField(*args, **kwargs)

   Bases: :py:obj:`AutoFieldMixin`, :py:obj:`IntegerField`


   Base class for all field types


   .. py:method:: get_internal_type()


   .. py:method:: rel_db_type(connection)

      Return the data type that a related field pointing to this field should
      use. For example, this method is called by ForeignKey and OneToOneField
      to determine its data type.



.. py:class:: BigAutoField(*args, **kwargs)

   Bases: :py:obj:`AutoFieldMixin`, :py:obj:`BigIntegerField`


   Base class for all field types


   .. py:method:: get_internal_type()


   .. py:method:: rel_db_type(connection)

      Return the data type that a related field pointing to this field should
      use. For example, this method is called by ForeignKey and OneToOneField
      to determine its data type.



.. py:class:: SmallAutoField(*args, **kwargs)

   Bases: :py:obj:`AutoFieldMixin`, :py:obj:`SmallIntegerField`


   Base class for all field types


   .. py:method:: get_internal_type()


   .. py:method:: rel_db_type(connection)

      Return the data type that a related field pointing to this field should
      use. For example, this method is called by ForeignKey and OneToOneField
      to determine its data type.



