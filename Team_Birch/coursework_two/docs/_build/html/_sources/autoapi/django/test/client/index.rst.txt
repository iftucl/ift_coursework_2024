django.test.client
==================

.. py:module:: django.test.client


Exceptions
----------

.. autoapisummary::

   django.test.client.RedirectCycleError


Classes
-------

.. autoapisummary::

   django.test.client.RequestFactory
   django.test.client.AsyncRequestFactory
   django.test.client.Client
   django.test.client.AsyncClient


Functions
---------

.. autoapisummary::

   django.test.client.encode_multipart
   django.test.client.encode_file


Module Contents
---------------

.. py:exception:: RedirectCycleError(message, last_response)

   Bases: :py:obj:`Exception`


   The test client has been asked to follow a redirect loop.


   .. py:attribute:: last_response


   .. py:attribute:: redirect_chain


.. py:function:: encode_multipart(boundary, data)

   Encode multipart POST data from a dictionary of form values.

   The key will be used as the form data name; the value will be transmitted
   as content. If the value is a file, the contents of the file will be sent
   as an application/octet-stream; otherwise, str(value) will be sent.


.. py:function:: encode_file(boundary, key, file)

.. py:class:: RequestFactory(*, json_encoder=DjangoJSONEncoder, headers=None, **defaults)

   Class that lets you create mock Request objects for use in testing.

   Usage:

   rf = RequestFactory()
   get_request = rf.get('/hello/')
   post_request = rf.post('/submit/', {'foo': 'bar'})

   Once you have a request object you can pass it to any view function,
   just as if that view had been hooked up using a URLconf.


   .. py:attribute:: json_encoder


   .. py:attribute:: defaults


   .. py:attribute:: cookies


   .. py:attribute:: errors


   .. py:method:: request(**request)

      Construct a generic request object.



   .. py:method:: get(path, data=None, secure=False, *, headers=None, **extra)

      Construct a GET request.



   .. py:method:: post(path, data=None, content_type=MULTIPART_CONTENT, secure=False, *, headers=None, **extra)

      Construct a POST request.



   .. py:method:: head(path, data=None, secure=False, *, headers=None, **extra)

      Construct a HEAD request.



   .. py:method:: trace(path, secure=False, *, headers=None, **extra)

      Construct a TRACE request.



   .. py:method:: options(path, data='', content_type='application/octet-stream', secure=False, *, headers=None, **extra)

      Construct an OPTIONS request.



   .. py:method:: put(path, data='', content_type='application/octet-stream', secure=False, *, headers=None, **extra)

      Construct a PUT request.



   .. py:method:: patch(path, data='', content_type='application/octet-stream', secure=False, *, headers=None, **extra)

      Construct a PATCH request.



   .. py:method:: delete(path, data='', content_type='application/octet-stream', secure=False, *, headers=None, **extra)

      Construct a DELETE request.



   .. py:method:: generic(method, path, data='', content_type='application/octet-stream', secure=False, *, headers=None, **extra)

      Construct an arbitrary HTTP request.



.. py:class:: AsyncRequestFactory(*, json_encoder=DjangoJSONEncoder, headers=None, **defaults)

   Bases: :py:obj:`RequestFactory`


   Class that lets you create mock ASGI-like Request objects for use in
   testing. Usage:

   rf = AsyncRequestFactory()
   get_request = await rf.get('/hello/')
   post_request = await rf.post('/submit/', {'foo': 'bar'})

   Once you have a request object you can pass it to any view function,
   including synchronous ones. The reason we have a separate class here is:
   a) this makes ASGIRequest subclasses, and
   b) AsyncTestClient can subclass it.


   .. py:method:: request(**request)

      Construct a generic request object.



   .. py:method:: generic(method, path, data='', content_type='application/octet-stream', secure=False, *, headers=None, **extra)

      Construct an arbitrary HTTP request.



.. py:class:: Client(enforce_csrf_checks=False, raise_request_exception=True, *, headers=None, **defaults)

   Bases: :py:obj:`ClientMixin`, :py:obj:`RequestFactory`


   A class that can act as a client for testing purposes.

   It allows the user to compose GET and POST requests, and
   obtain the response that the server gave to those requests.
   The server Response objects are annotated with the details
   of the contexts and templates that were rendered during the
   process of serving the request.

   Client objects are stateful - they will retain cookie (and
   thus session) details for the lifetime of the Client instance.

   This is not intended as a replacement for Twill/Selenium or
   the like - it is here to allow testing against the
   contexts and templates produced by a view, rather than the
   HTML rendered to the end-user.


   .. py:attribute:: handler


   .. py:attribute:: raise_request_exception
      :value: True



   .. py:attribute:: exc_info
      :value: None



   .. py:attribute:: extra
      :value: None



   .. py:attribute:: headers
      :value: None



   .. py:method:: request(**request)

      Make a generic request. Compose the environment dictionary and pass
      to the handler, return the result of the handler. Assume defaults for
      the query environment, which can be overridden using the arguments to
      the request.



   .. py:method:: get(path, data=None, follow=False, secure=False, *, headers=None, **extra)

      Request a response from the server using GET.



   .. py:method:: post(path, data=None, content_type=MULTIPART_CONTENT, follow=False, secure=False, *, headers=None, **extra)

      Request a response from the server using POST.



   .. py:method:: head(path, data=None, follow=False, secure=False, *, headers=None, **extra)

      Request a response from the server using HEAD.



   .. py:method:: options(path, data='', content_type='application/octet-stream', follow=False, secure=False, *, headers=None, **extra)

      Request a response from the server using OPTIONS.



   .. py:method:: put(path, data='', content_type='application/octet-stream', follow=False, secure=False, *, headers=None, **extra)

      Send a resource to the server using PUT.



   .. py:method:: patch(path, data='', content_type='application/octet-stream', follow=False, secure=False, *, headers=None, **extra)

      Send a resource to the server using PATCH.



   .. py:method:: delete(path, data='', content_type='application/octet-stream', follow=False, secure=False, *, headers=None, **extra)

      Send a DELETE request to the server.



   .. py:method:: trace(path, data='', follow=False, secure=False, *, headers=None, **extra)

      Send a TRACE request to the server.



.. py:class:: AsyncClient(enforce_csrf_checks=False, raise_request_exception=True, *, headers=None, **defaults)

   Bases: :py:obj:`ClientMixin`, :py:obj:`AsyncRequestFactory`


   An async version of Client that creates ASGIRequests and calls through an
   async request path.

   Does not currently support "follow" on its methods.


   .. py:attribute:: handler


   .. py:attribute:: raise_request_exception
      :value: True



   .. py:attribute:: exc_info
      :value: None



   .. py:attribute:: extra
      :value: None



   .. py:attribute:: headers
      :value: None



   .. py:method:: request(**request)
      :async:


      Make a generic request. Compose the scope dictionary and pass to the
      handler, return the result of the handler. Assume defaults for the
      query environment, which can be overridden using the arguments to the
      request.



