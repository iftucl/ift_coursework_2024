django.core.serializers.json
============================

.. py:module:: django.core.serializers.json

.. autoapi-nested-parse::

   Serialize data to/from JSON



Classes
-------

.. autoapisummary::

   django.core.serializers.json.Serializer
   django.core.serializers.json.DjangoJSONEncoder


Functions
---------

.. autoapisummary::

   django.core.serializers.json.Deserializer


Module Contents
---------------

.. py:class:: Serializer

   Bases: :py:obj:`django.core.serializers.python.Serializer`


   Convert a queryset to JSON.


   .. py:attribute:: internal_use_only
      :value: False



   .. py:method:: start_serialization()


   .. py:method:: end_serialization()


   .. py:method:: end_object(obj)


   .. py:method:: getvalue()


.. py:function:: Deserializer(stream_or_string, **options)

   Deserialize a stream or string of JSON data.


.. py:class:: DjangoJSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   JSONEncoder subclass that knows how to encode date/time, decimal types, and
   UUIDs.


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return super().default(o)




