django.db.models.functions.comparison
=====================================

.. py:module:: django.db.models.functions.comparison

.. autoapi-nested-parse::

   Database functions that do comparisons or type conversions.



Classes
-------

.. autoapisummary::

   django.db.models.functions.comparison.Cast
   django.db.models.functions.comparison.Coalesce
   django.db.models.functions.comparison.Collate
   django.db.models.functions.comparison.Greatest
   django.db.models.functions.comparison.JSONObject
   django.db.models.functions.comparison.Least
   django.db.models.functions.comparison.NullIf


Module Contents
---------------

.. py:class:: Cast(expression, output_field)

   Bases: :py:obj:`django.db.models.expressions.Func`


   Coerce an expression to a new field type.


   .. py:attribute:: function
      :value: 'CAST'



   .. py:attribute:: template
      :value: '%(function)s(%(expressions)s AS %(db_type)s)'



   .. py:method:: as_sql(compiler, connection, **extra_context)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



   .. py:method:: as_sqlite(compiler, connection, **extra_context)


   .. py:method:: as_mysql(compiler, connection, **extra_context)


   .. py:method:: as_postgresql(compiler, connection, **extra_context)


   .. py:method:: as_oracle(compiler, connection, **extra_context)


.. py:class:: Coalesce(*expressions, **extra)

   Bases: :py:obj:`django.db.models.expressions.Func`


   Return, from left to right, the first non-null expression.


   .. py:attribute:: function
      :value: 'COALESCE'



   .. py:property:: empty_result_set_value


   .. py:method:: as_oracle(compiler, connection, **extra_context)


.. py:class:: Collate(expression, collation)

   Bases: :py:obj:`django.db.models.expressions.Func`


   An SQL function call.


   .. py:attribute:: function
      :value: 'COLLATE'



   .. py:attribute:: template
      :value: '%(expressions)s %(function)s %(collation)s'



   .. py:attribute:: collation_re


   .. py:attribute:: collation


   .. py:method:: as_sql(compiler, connection, **extra_context)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



.. py:class:: Greatest(*expressions, **extra)

   Bases: :py:obj:`django.db.models.expressions.Func`


   Return the maximum expression.

   If any expression is null the return value is database-specific:
   On PostgreSQL, the maximum not-null expression is returned.
   On MySQL, Oracle, and SQLite, if any expression is null, null is returned.


   .. py:attribute:: function
      :value: 'GREATEST'



   .. py:method:: as_sqlite(compiler, connection, **extra_context)

      Use the MAX function on SQLite.



.. py:class:: JSONObject(**fields)

   Bases: :py:obj:`django.db.models.expressions.Func`


   An SQL function call.


   .. py:attribute:: function
      :value: 'JSON_OBJECT'



   .. py:attribute:: output_field

      Return the output type of this expressions.


   .. py:method:: as_sql(compiler, connection, **extra_context)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



   .. py:method:: as_postgresql(compiler, connection, **extra_context)


   .. py:method:: as_oracle(compiler, connection, **extra_context)


.. py:class:: Least(*expressions, **extra)

   Bases: :py:obj:`django.db.models.expressions.Func`


   Return the minimum expression.

   If any expression is null the return value is database-specific:
   On PostgreSQL, return the minimum not-null expression.
   On MySQL, Oracle, and SQLite, if any expression is null, return null.


   .. py:attribute:: function
      :value: 'LEAST'



   .. py:method:: as_sqlite(compiler, connection, **extra_context)

      Use the MIN function on SQLite.



.. py:class:: NullIf(*expressions, output_field=None, **extra)

   Bases: :py:obj:`django.db.models.expressions.Func`


   An SQL function call.


   .. py:attribute:: function
      :value: 'NULLIF'



   .. py:attribute:: arity
      :value: 2



   .. py:method:: as_oracle(compiler, connection, **extra_context)


