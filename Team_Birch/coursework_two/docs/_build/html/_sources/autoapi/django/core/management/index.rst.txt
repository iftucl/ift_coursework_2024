django.core.management
======================

.. py:module:: django.core.management


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/django/core/management/base/index
   /autoapi/django/core/management/color/index
   /autoapi/django/core/management/commands/index
   /autoapi/django/core/management/sql/index
   /autoapi/django/core/management/templates/index
   /autoapi/django/core/management/utils/index


Classes
-------

.. autoapisummary::

   django.core.management.ManagementUtility


Functions
---------

.. autoapisummary::

   django.core.management.find_commands
   django.core.management.load_command_class
   django.core.management.get_commands
   django.core.management.call_command
   django.core.management.execute_from_command_line


Package Contents
----------------

.. py:function:: find_commands(management_dir)

   Given a path to a management directory, return a list of all the command
   names that are available.


.. py:function:: load_command_class(app_name, name)

   Given a command name and an application name, return the Command
   class instance. Allow all errors raised by the import process
   (ImportError, AttributeError) to propagate.


.. py:function:: get_commands()

   Return a dictionary mapping command names to their callback applications.

   Look for a management.commands package in django.core, and in each
   installed application -- if a commands package exists, register all
   commands in that package.

   Core commands are always included. If a settings module has been
   specified, also include user-defined commands.

   The dictionary is in the format {command_name: app_name}. Key-value
   pairs from this dictionary can then be used in calls to
   load_command_class(app_name, command_name)

   The dictionary is cached on the first call and reused on subsequent
   calls.


.. py:function:: call_command(command_name, *args, **options)

   Call the given command, with the given options and args/kwargs.

   This is the primary API you should use for calling specific commands.

   `command_name` may be a string or a command object. Using a string is
   preferred unless the command object is required for further processing or
   testing.

   Some examples:
       call_command('migrate')
       call_command('shell', plain=True)
       call_command('sqlmigrate', 'myapp')

       from django.core.management.commands import flush
       cmd = flush.Command()
       call_command(cmd, verbosity=0, interactive=False)
       # Do something with cmd ...


.. py:class:: ManagementUtility(argv=None)

   Encapsulate the logic of the django-admin and manage.py utilities.


   .. py:attribute:: argv


   .. py:attribute:: prog_name


   .. py:attribute:: settings_exception
      :value: None



   .. py:method:: main_help_text(commands_only=False)

      Return the script's main help text, as a string.



   .. py:method:: fetch_command(subcommand)

      Try to fetch the given subcommand, printing a message with the
      appropriate command called from the command line (usually
      "django-admin" or "manage.py") if it can't be found.



   .. py:method:: autocomplete()

      Output completion suggestions for BASH.

      The output of this function is passed to BASH's `COMREPLY` variable and
      treated as completion suggestions. `COMREPLY` expects a space
      separated string as the result.

      The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used
      to get information about the cli input. Please refer to the BASH
      man-page for more information about this variables.

      Subcommand options are saved as pairs. A pair consists of
      the long option string (e.g. '--exclude') and a boolean
      value indicating if the option requires arguments. When printing to
      stdout, an equal sign is appended to options which require arguments.

      Note: If debugging this function, it is recommended to write the debug
      output in a separate file. Otherwise the debug output will be treated
      and formatted as potential completion suggestions.



   .. py:method:: execute()

      Given the command-line arguments, figure out which subcommand is being
      run, create a parser appropriate to that command, and run it.



.. py:function:: execute_from_command_line(argv=None)

   Run a ManagementUtility.


