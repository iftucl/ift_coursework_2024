django.contrib.auth.hashers
===========================

.. py:module:: django.contrib.auth.hashers


Attributes
----------

.. autoapisummary::

   django.contrib.auth.hashers.UNUSABLE_PASSWORD_PREFIX
   django.contrib.auth.hashers.UNUSABLE_PASSWORD_SUFFIX_LENGTH


Classes
-------

.. autoapisummary::

   django.contrib.auth.hashers.BasePasswordHasher
   django.contrib.auth.hashers.PBKDF2PasswordHasher
   django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher
   django.contrib.auth.hashers.Argon2PasswordHasher
   django.contrib.auth.hashers.BCryptSHA256PasswordHasher
   django.contrib.auth.hashers.BCryptPasswordHasher
   django.contrib.auth.hashers.ScryptPasswordHasher
   django.contrib.auth.hashers.SHA1PasswordHasher
   django.contrib.auth.hashers.MD5PasswordHasher
   django.contrib.auth.hashers.UnsaltedSHA1PasswordHasher
   django.contrib.auth.hashers.UnsaltedMD5PasswordHasher
   django.contrib.auth.hashers.CryptPasswordHasher


Functions
---------

.. autoapisummary::

   django.contrib.auth.hashers.is_password_usable
   django.contrib.auth.hashers.check_password
   django.contrib.auth.hashers.make_password
   django.contrib.auth.hashers.get_hashers
   django.contrib.auth.hashers.get_hashers_by_algorithm
   django.contrib.auth.hashers.reset_hashers
   django.contrib.auth.hashers.get_hasher
   django.contrib.auth.hashers.identify_hasher
   django.contrib.auth.hashers.mask_hash
   django.contrib.auth.hashers.must_update_salt


Module Contents
---------------

.. py:data:: UNUSABLE_PASSWORD_PREFIX
   :value: '!'


.. py:data:: UNUSABLE_PASSWORD_SUFFIX_LENGTH
   :value: 40


.. py:function:: is_password_usable(encoded)

   Return True if this password wasn't generated by
   User.set_unusable_password(), i.e. make_password(None).


.. py:function:: check_password(password, encoded, setter=None, preferred='default')

   Return a boolean of whether the raw password matches the three
   part encoded digest.

   If setter is specified, it'll be called when you need to
   regenerate the password.


.. py:function:: make_password(password, salt=None, hasher='default')

   Turn a plain-text password into a hash for database storage

   Same as encode() but generate a new random salt. If password is None then
   return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
   which disallows logins. Additional random string reduces chances of gaining
   access to staff or superuser accounts. See ticket #20079 for more info.


.. py:function:: get_hashers()

.. py:function:: get_hashers_by_algorithm()

.. py:function:: reset_hashers(*, setting, **kwargs)

.. py:function:: get_hasher(algorithm='default')

   Return an instance of a loaded password hasher.

   If algorithm is 'default', return the default hasher. Lazily import hashers
   specified in the project's settings file if needed.


.. py:function:: identify_hasher(encoded)

   Return an instance of a loaded password hasher.

   Identify hasher algorithm by examining encoded hash, and call
   get_hasher() to return hasher. Raise ValueError if
   algorithm cannot be identified, or if hasher is not loaded.


.. py:function:: mask_hash(hash, show=6, char='*')

   Return the given hash, with only the first ``show`` number shown. The
   rest are masked with ``char`` for security reasons.


.. py:function:: must_update_salt(salt, expected_entropy)

.. py:class:: BasePasswordHasher

   Abstract base class for password hashers

   When creating your own hasher, you need to override algorithm,
   verify(), encode() and safe_summary().

   PasswordHasher objects are immutable.


   .. py:attribute:: algorithm
      :value: None



   .. py:attribute:: library
      :value: None



   .. py:attribute:: salt_entropy
      :value: 128



   .. py:method:: salt()

      Generate a cryptographically secure nonce salt in ASCII with an entropy
      of at least `salt_entropy` bits.



   .. py:method:: verify(password, encoded)
      :abstractmethod:


      Check if the given password is correct.



   .. py:method:: encode(password, salt)
      :abstractmethod:


      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)
      :abstractmethod:


      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: safe_summary(encoded)
      :abstractmethod:


      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: PBKDF2PasswordHasher

   Bases: :py:obj:`BasePasswordHasher`


   Secure password hashing using the PBKDF2 algorithm (recommended)

   Configured to use PBKDF2 + HMAC + SHA256.
   The result is a 64 byte binary string.  Iterations may be changed
   safely but you must rename the algorithm if you change SHA256.


   .. py:attribute:: algorithm
      :value: 'pbkdf2_sha256'



   .. py:attribute:: iterations
      :value: 600000



   .. py:attribute:: digest


   .. py:method:: encode(password, salt, iterations=None)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: PBKDF2SHA1PasswordHasher

   Bases: :py:obj:`PBKDF2PasswordHasher`


   Alternate PBKDF2 hasher which uses SHA1, the default PRF
   recommended by PKCS #5. This is compatible with other
   implementations of PBKDF2, such as openssl's
   PKCS5_PBKDF2_HMAC_SHA1().


   .. py:attribute:: algorithm
      :value: 'pbkdf2_sha1'



   .. py:attribute:: digest


.. py:class:: Argon2PasswordHasher

   Bases: :py:obj:`BasePasswordHasher`


   Secure password hashing using the argon2 algorithm.

   This is the winner of the Password Hashing Competition 2013-2015
   (https://password-hashing.net). It requires the argon2-cffi library which
   depends on native C code and might cause portability issues.


   .. py:attribute:: algorithm
      :value: 'argon2'



   .. py:attribute:: library
      :value: 'argon2'



   .. py:attribute:: time_cost
      :value: 2



   .. py:attribute:: memory_cost
      :value: 102400



   .. py:attribute:: parallelism
      :value: 8



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



   .. py:method:: params()


.. py:class:: BCryptSHA256PasswordHasher

   Bases: :py:obj:`BasePasswordHasher`


   Secure password hashing using the bcrypt algorithm (recommended)

   This is considered by many to be the most secure algorithm but you
   must first install the bcrypt library.  Please be warned that
   this library depends on native C code and might cause portability
   issues.


   .. py:attribute:: algorithm
      :value: 'bcrypt_sha256'



   .. py:attribute:: digest


   .. py:attribute:: library
      :value: ('bcrypt', 'bcrypt')



   .. py:attribute:: rounds
      :value: 12



   .. py:method:: salt()

      Generate a cryptographically secure nonce salt in ASCII with an entropy
      of at least `salt_entropy` bits.



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: BCryptPasswordHasher

   Bases: :py:obj:`BCryptSHA256PasswordHasher`


   Secure password hashing using the bcrypt algorithm

   This is considered by many to be the most secure algorithm but you
   must first install the bcrypt library.  Please be warned that
   this library depends on native C code and might cause portability
   issues.

   This hasher does not first hash the password which means it is subject to
   bcrypt's 72 bytes password truncation. Most use cases should prefer the
   BCryptSHA256PasswordHasher.


   .. py:attribute:: algorithm
      :value: 'bcrypt'



   .. py:attribute:: digest
      :value: None



.. py:class:: ScryptPasswordHasher

   Bases: :py:obj:`BasePasswordHasher`


   Secure password hashing using the Scrypt algorithm.


   .. py:attribute:: algorithm
      :value: 'scrypt'



   .. py:attribute:: block_size
      :value: 8



   .. py:attribute:: maxmem
      :value: 0



   .. py:attribute:: parallelism
      :value: 1



   .. py:attribute:: work_factor
      :value: 16384



   .. py:method:: encode(password, salt, n=None, r=None, p=None)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: SHA1PasswordHasher(*args, **kwargs)

   Bases: :py:obj:`BasePasswordHasher`


   The SHA1 password hashing algorithm (not recommended)


   .. py:attribute:: algorithm
      :value: 'sha1'



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: MD5PasswordHasher

   Bases: :py:obj:`BasePasswordHasher`


   The Salted MD5 password hashing algorithm (not recommended)


   .. py:attribute:: algorithm
      :value: 'md5'



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: must_update(encoded)


   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: UnsaltedSHA1PasswordHasher(*args, **kwargs)

   Bases: :py:obj:`BasePasswordHasher`


   Very insecure algorithm that you should *never* use; store SHA1 hashes
   with an empty salt.

   This class is implemented because Django used to accept such password
   hashes. Some older Django installs still have these values lingering
   around so we need to handle and upgrade them properly.


   .. py:attribute:: algorithm
      :value: 'unsalted_sha1'



   .. py:method:: salt()

      Generate a cryptographically secure nonce salt in ASCII with an entropy
      of at least `salt_entropy` bits.



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: UnsaltedMD5PasswordHasher(*args, **kwargs)

   Bases: :py:obj:`BasePasswordHasher`


   Incredibly insecure algorithm that you should *never* use; stores unsalted
   MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an
   empty salt.

   This class is implemented because Django used to store passwords this way
   and to accept such password hashes. Some older Django installs still have
   these values lingering around so we need to handle and upgrade them
   properly.


   .. py:attribute:: algorithm
      :value: 'unsalted_md5'



   .. py:method:: salt()

      Generate a cryptographically secure nonce salt in ASCII with an entropy
      of at least `salt_entropy` bits.



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



.. py:class:: CryptPasswordHasher(*args, **kwargs)

   Bases: :py:obj:`BasePasswordHasher`


   Password hashing using UNIX crypt (not recommended)

   The crypt module is not supported on all platforms.


   .. py:attribute:: algorithm
      :value: 'crypt'



   .. py:attribute:: library
      :value: 'crypt'



   .. py:method:: salt()

      Generate a cryptographically secure nonce salt in ASCII with an entropy
      of at least `salt_entropy` bits.



   .. py:method:: encode(password, salt)

      Create an encoded database value.

      The result is normally formatted as "algorithm$salt$hash" and
      must be fewer than 128 characters.



   .. py:method:: decode(encoded)

      Return a decoded database value.

      The result is a dictionary and should contain `algorithm`, `hash`, and
      `salt`. Extra keys can be algorithm specific like `iterations` or
      `work_factor`.



   .. py:method:: verify(password, encoded)

      Check if the given password is correct.



   .. py:method:: safe_summary(encoded)

      Return a summary of safe values.

      The result is a dictionary and will be used where the password field
      must be displayed to construct a safe representation of the password.



   .. py:method:: harden_runtime(password, encoded)

      Bridge the runtime gap between the work factor supplied in `encoded`
      and the work factor suggested by this hasher.

      Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and
      `self.iterations` is 30000, this method should run password through
      another 10000 iterations of PBKDF2. Similar approaches should exist
      for any hasher that has a work factor. If not, this method should be
      defined as a no-op to silence the warning.



