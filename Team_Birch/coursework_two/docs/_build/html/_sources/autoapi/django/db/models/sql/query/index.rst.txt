django.db.models.sql.query
==========================

.. py:module:: django.db.models.sql.query

.. autoapi-nested-parse::

   Create SQL statements for QuerySets.

   The code in here encapsulates all of the SQL construction so that QuerySets
   themselves do not have to (and could be backed by things other than SQL
   databases). The abstraction barrier only works one way: this module has to know
   all about the internals of models in order to get the information it needs.



Classes
-------

.. autoapisummary::

   django.db.models.sql.query.RawQuery
   django.db.models.sql.query.Query


Module Contents
---------------

.. py:class:: RawQuery(sql, using, params=())

   A single raw SQL query.


   .. py:attribute:: params
      :value: ()



   .. py:attribute:: sql


   .. py:attribute:: using


   .. py:attribute:: cursor
      :value: None



   .. py:attribute:: extra_select


   .. py:attribute:: annotation_select


   .. py:method:: chain(using)


   .. py:method:: clone(using)


   .. py:method:: get_columns()


   .. py:property:: params_type


.. py:class:: Query(model, alias_cols=True)

   Bases: :py:obj:`django.db.models.expressions.BaseExpression`


   A single SQL query.


   .. py:attribute:: alias_prefix
      :value: 'T'



   .. py:attribute:: empty_result_set_value
      :value: None



   .. py:attribute:: subq_aliases


   .. py:attribute:: compiler
      :value: 'SQLCompiler'



   .. py:attribute:: base_table_class


   .. py:attribute:: join_class


   .. py:attribute:: default_cols
      :value: True



   .. py:attribute:: default_ordering
      :value: True



   .. py:attribute:: standard_ordering
      :value: True



   .. py:attribute:: filter_is_sticky
      :value: False



   .. py:attribute:: subquery
      :value: False



   .. py:attribute:: select
      :value: ()



   .. py:attribute:: group_by
      :value: None



   .. py:attribute:: order_by
      :value: ()



   .. py:attribute:: low_mark
      :value: 0



   .. py:attribute:: high_mark
      :value: None



   .. py:attribute:: distinct
      :value: False



   .. py:attribute:: distinct_fields
      :value: ()



   .. py:attribute:: select_for_update
      :value: False



   .. py:attribute:: select_for_update_nowait
      :value: False



   .. py:attribute:: select_for_update_skip_locked
      :value: False



   .. py:attribute:: select_for_update_of
      :value: ()



   .. py:attribute:: select_for_no_key_update
      :value: False



   .. py:attribute:: select_related
      :value: False



   .. py:attribute:: has_select_fields
      :value: False



   .. py:attribute:: max_depth
      :value: 5



   .. py:attribute:: values_select
      :value: ()



   .. py:attribute:: annotation_select_mask
      :value: None



   .. py:attribute:: combinator
      :value: None



   .. py:attribute:: combinator_all
      :value: False



   .. py:attribute:: combined_queries
      :value: ()



   .. py:attribute:: extra_select_mask
      :value: None



   .. py:attribute:: extra_tables
      :value: ()



   .. py:attribute:: extra_order_by
      :value: ()



   .. py:attribute:: deferred_loading


   .. py:attribute:: explain_info
      :value: None



   .. py:attribute:: model


   .. py:attribute:: alias_refcount


   .. py:attribute:: alias_map


   .. py:attribute:: alias_cols
      :value: True



   .. py:attribute:: external_aliases


   .. py:attribute:: table_map


   .. py:attribute:: used_aliases


   .. py:attribute:: where


   .. py:attribute:: annotations


   .. py:attribute:: extra


   .. py:property:: output_field

      Return the output type of this expressions.


   .. py:method:: base_table()


   .. py:method:: sql_with_params()

      Return the query as an SQL string and the parameters that will be
      substituted into the query.



   .. py:method:: get_compiler(using=None, connection=None, elide_empty=True)


   .. py:method:: get_meta()

      Return the Options instance (the model._meta) from which to start
      processing. Normally, this is self.model._meta, but it can be changed
      by subclasses.



   .. py:method:: clone()

      Return a copy of the current Query. A lightweight alternative to
      deepcopy().



   .. py:method:: chain(klass=None)

      Return a copy of the current Query that's ready for another operation.
      The klass argument changes the type of the Query, e.g. UpdateQuery.



   .. py:method:: relabeled_clone(change_map)


   .. py:method:: get_aggregation(using, aggregate_exprs)

      Return the dictionary with the values of the existing aggregations.



   .. py:method:: get_count(using)

      Perform a COUNT() query using the current filter constraints.



   .. py:method:: has_filters()


   .. py:method:: exists(limit=True)


   .. py:method:: has_results(using)


   .. py:method:: explain(using, format=None, **options)


   .. py:method:: combine(rhs, connector)

      Merge the 'rhs' query into the current one (with any 'rhs' effects
      being applied *after* (that is, "to the right of") anything in the
      current query. 'rhs' is not modified during a call to this function.

      The 'connector' parameter describes how to connect filters from the
      'rhs' query.



   .. py:method:: get_select_mask()

      Convert the self.deferred_loading data structure to an alternate data
      structure, describing the field that *will* be loaded. This is used to
      compute the columns to select from the database and also by the
      QuerySet class to work out which fields are being initialized on each
      model. Models that have all their fields included aren't mentioned in
      the result, only those that have field restrictions in place.



   .. py:method:: table_alias(table_name, create=False, filtered_relation=None)

      Return a table alias for the given table_name and whether this is a
      new alias or not.

      If 'create' is true, a new alias is always created. Otherwise, the
      most recently created alias for the table (if one exists) is reused.



   .. py:method:: ref_alias(alias)

      Increases the reference count for this alias.



   .. py:method:: unref_alias(alias, amount=1)

      Decreases the reference count for this alias.



   .. py:method:: promote_joins(aliases)

      Promote recursively the join type of given aliases and its children to
      an outer join. If 'unconditional' is False, only promote the join if
      it is nullable or the parent join is an outer join.

      The children promotion is done to avoid join chains that contain a LOUTER
      b INNER c. So, if we have currently a INNER b INNER c and a->b is promoted,
      then we must also promote b->c automatically, or otherwise the promotion
      of a->b doesn't actually change anything in the query results.



   .. py:method:: demote_joins(aliases)

      Change join type from LOUTER to INNER for all joins in aliases.

      Similarly to promote_joins(), this method must ensure no join chains
      containing first an outer, then an inner join are generated. If we
      are demoting b->c join in chain a LOUTER b LOUTER c then we must
      demote a->b automatically, or otherwise the demotion of b->c doesn't
      actually change anything in the query results. .



   .. py:method:: reset_refcounts(to_counts)

      Reset reference counts for aliases so that they match the value passed
      in `to_counts`.



   .. py:method:: change_aliases(change_map)

      Change the aliases in change_map (which maps old-alias -> new-alias),
      relabelling any references to them in select columns and the where
      clause.



   .. py:method:: bump_prefix(other_query, exclude=None)

      Change the alias prefix to the next letter in the alphabet in a way
      that the other query's aliases and this query's aliases will not
      conflict. Even tables that previously had no alias will get an alias
      after this call. To prevent changing aliases use the exclude parameter.



   .. py:method:: get_initial_alias()

      Return the first alias for this query, after increasing its reference
      count.



   .. py:method:: count_active_tables()

      Return the number of tables in this query with a non-zero reference
      count. After execution, the reference counts are zeroed, so tables
      added in compiler will not be seen by this method.



   .. py:method:: join(join, reuse=None, reuse_with_filtered_relation=False)

      Return an alias for the 'join', either reusing an existing alias for
      that join or creating a new one. 'join' is either a base_table_class or
      join_class.

      The 'reuse' parameter can be either None which means all joins are
      reusable, or it can be a set containing the aliases that can be reused.

      The 'reuse_with_filtered_relation' parameter is used when computing
      FilteredRelation instances.

      A join is always created as LOUTER if the lhs alias is LOUTER to make
      sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new
      joins are created as LOUTER if the join is nullable.



   .. py:method:: join_parent_model(opts, model, alias, seen)

      Make sure the given 'model' is joined in the query. If 'model' isn't
      a parent of 'opts' or if it is None this method is a no-op.

      The 'alias' is the root alias for starting the join, 'seen' is a dict
      of model -> alias of existing joins. It must also contain a mapping
      of None -> some alias. This will be returned in the no-op case.



   .. py:method:: check_alias(alias)


   .. py:method:: add_annotation(annotation, alias, select=True)

      Add a single annotation expression to the Query.



   .. py:method:: resolve_expression(query, *args, **kwargs)

      Provide the chance to do any preprocessing or validation before being
      added to the query.

      :param \* query: the backend query implementation
      :param \* allow_joins: boolean allowing or denying use of joins
                             in this query
      :param \* reuse: a set of reusable joins for multijoins
      :param \* summarize: a terminal aggregate clause
      :param \* for_save: whether this expression about to be used in a save or update

      Return: an Expression to be added to the query.



   .. py:method:: get_external_cols()


   .. py:method:: get_group_by_cols(wrapper=None)


   .. py:method:: as_sql(compiler, connection)

      Responsible for returning a (sql, [params]) tuple to be included
      in the current query.

      Different backends can provide their own implementation, by
      providing an `as_{vendor}` method and patching the Expression:

      ```
      def override_as_sql(self, compiler, connection):
          # custom logic
          return super().as_sql(compiler, connection)
      setattr(Expression, 'as_' + connection.vendor, override_as_sql)
      ```

      :param \* compiler: the query compiler responsible for generating the query.
                          Must have a compile method, returning a (sql, [params]) tuple.
                          Calling compiler(value) will return a quoted `value`.
      :param \* connection: the database connection used for the current query.

      Return: (sql, params)
        Where `sql` is a string containing ordered sql parameters to be
        replaced with the elements of the list `params`.



   .. py:method:: resolve_lookup_value(value, can_reuse, allow_joins, summarize=False)


   .. py:method:: solve_lookup_type(lookup, summarize=False)

      Solve the lookup type from the lookup (e.g.: 'foobar__id__icontains').



   .. py:method:: check_query_object_type(value, opts, field)

      Check whether the object passed while querying is of the correct type.
      If not, raise a ValueError specifying the wrong object.



   .. py:method:: check_related_objects(field, value, opts)

      Check the type of object passed to query relations.



   .. py:method:: check_filterable(expression)

      Raise an error if expression cannot be used in a WHERE clause.



   .. py:method:: build_lookup(lookups, lhs, rhs)

      Try to extract transforms and lookup from given lhs.

      The lhs value is something that works like SQLExpression.
      The rhs value is what the lookup is going to compare against.
      The lookups is a list of names to extract using get_lookup()
      and get_transform().



   .. py:method:: try_transform(lhs, name)

      Helper method for build_lookup(). Try to fetch and initialize
      a transform for name parameter from lhs.



   .. py:method:: build_filter(filter_expr, branch_negated=False, current_negated=False, can_reuse=None, allow_joins=True, split_subq=True, reuse_with_filtered_relation=False, check_filterable=True, summarize=False)

      Build a WhereNode for a single filter clause but don't add it
      to this Query. Query.add_q() will then add this filter to the where
      Node.

      The 'branch_negated' tells us if the current branch contains any
      negations. This will be used to determine if subqueries are needed.

      The 'current_negated' is used to determine if the current filter is
      negated or not and this will be used to determine if IS NULL filtering
      is needed.

      The difference between current_negated and branch_negated is that
      branch_negated is set on first negation, but current_negated is
      flipped for each negation.

      Note that add_filter will not do any negating itself, that is done
      upper in the code by add_q().

      The 'can_reuse' is a set of reusable joins for multijoins.

      If 'reuse_with_filtered_relation' is True, then only joins in can_reuse
      will be reused.

      The method will create a filter clause that can be added to the current
      query. However, if the filter isn't added to the query then the caller
      is responsible for unreffing the joins used.



   .. py:method:: add_filter(filter_lhs, filter_rhs)


   .. py:method:: add_q(q_object)

      A preprocessor for the internal _add_q(). Responsible for doing final
      join promotion.



   .. py:method:: build_where(filter_expr)


   .. py:method:: clear_where()


   .. py:method:: build_filtered_relation_q(q_object, reuse, branch_negated=False, current_negated=False)

      Add a FilteredRelation object to the current filter.



   .. py:method:: add_filtered_relation(filtered_relation, alias)


   .. py:method:: names_to_path(names, opts, allow_many=True, fail_on_missing=False)

      Walk the list of names and turns them into PathInfo tuples. A single
      name in 'names' can generate multiple PathInfos (m2m, for example).

      'names' is the path of names to travel, 'opts' is the model Options we
      start the name resolving from, 'allow_many' is as for setup_joins().
      If fail_on_missing is set to True, then a name that can't be resolved
      will generate a FieldError.

      Return a list of PathInfo tuples. In addition return the final field
      (the last used join field) and target (which is a field guaranteed to
      contain the same value as the final field). Finally, return those names
      that weren't found (which are likely transforms and the final lookup).



   .. py:method:: setup_joins(names, opts, alias, can_reuse=None, allow_many=True, reuse_with_filtered_relation=False)

      Compute the necessary table joins for the passage through the fields
      given in 'names'. 'opts' is the Options class for the current model
      (which gives the table we are starting from), 'alias' is the alias for
      the table to start the joining from.

      The 'can_reuse' defines the reverse foreign key joins we can reuse. It
      can be None in which case all joins are reusable or a set of aliases
      that can be reused. Note that non-reverse foreign keys are always
      reusable when using setup_joins().

      The 'reuse_with_filtered_relation' can be used to force 'can_reuse'
      parameter and force the relation on the given connections.

      If 'allow_many' is False, then any reverse foreign key seen will
      generate a MultiJoin exception.

      Return the final field involved in the joins, the target field (used
      for any 'where' constraint), the final 'opts' value, the joins, the
      field path traveled to generate the joins, and a transform function
      that takes a field and alias and is equivalent to `field.get_col(alias)`
      in the simple case but wraps field transforms if they were included in
      names.

      The target field is the field containing the concrete value. Final
      field can be something different, for example foreign key pointing to
      that value. Final field is needed for example in some value
      conversions (convert 'obj' in fk__id=obj to pk val using the foreign
      key field for example).



   .. py:method:: trim_joins(targets, joins, path)

      The 'target' parameter is the final field being joined to, 'joins'
      is the full list of join aliases. The 'path' contain the PathInfos
      used to create the joins.

      Return the final target field and table alias and the new active
      joins.

      Always trim any direct join if the target column is already in the
      previous table. Can't trim reverse joins as it's unknown if there's
      anything on the other side of the join.



   .. py:method:: resolve_ref(name, allow_joins=True, reuse=None, summarize=False)


   .. py:method:: split_exclude(filter_expr, can_reuse, names_with_path)

      When doing an exclude against any kind of N-to-many relation, we need
      to use a subquery. This method constructs the nested query, given the
      original exclude filter (filter_expr) and the portion up to the first
      N-to-many relation field.

      For example, if the origin filter is ~Q(child__name='foo'), filter_expr
      is ('child__name', 'foo') and can_reuse is a set of joins usable for
      filters in the original query.

      We will turn this into equivalent of:
          WHERE NOT EXISTS(
              SELECT 1
              FROM child
              WHERE name = 'foo' AND child.parent_id = parent.id
              LIMIT 1
          )



   .. py:method:: set_empty()


   .. py:method:: is_empty()


   .. py:method:: set_limits(low=None, high=None)

      Adjust the limits on the rows retrieved. Use low/high to set these,
      as it makes it more Pythonic to read and write. When the SQL query is
      created, convert them to the appropriate offset and limit values.

      Apply any limits passed in here to the existing constraints. Add low
      to the current low value and clamp both to any existing high value.



   .. py:method:: clear_limits()

      Clear any existing limits.



   .. py:property:: is_sliced


   .. py:method:: has_limit_one()


   .. py:method:: can_filter()

      Return True if adding filters to this instance is still possible.

      Typically, this means no limits or offsets have been put on the results.



   .. py:method:: clear_select_clause()

      Remove all fields from SELECT clause.



   .. py:method:: clear_select_fields()

      Clear the list of fields to select (but not extra_select columns).
      Some queryset types completely replace any existing list of select
      columns.



   .. py:method:: add_select_col(col, name)


   .. py:method:: set_select(cols)


   .. py:method:: add_distinct_fields(*field_names)

      Add and resolve the given fields to the query's "distinct on" clause.



   .. py:method:: add_fields(field_names, allow_m2m=True)

      Add the given (model) fields to the select set. Add the field names in
      the order specified.



   .. py:method:: add_ordering(*ordering)

      Add items from the 'ordering' sequence to the query's "order by"
      clause. These items are either field names (not column names) --
      possibly with a direction prefix ('-' or '?') -- or OrderBy
      expressions.

      If 'ordering' is empty, clear all ordering from the query.



   .. py:method:: clear_ordering(force=False, clear_default=True)

      Remove any ordering settings if the current query allows it without
      side effects, set 'force' to True to clear the ordering regardless.
      If 'clear_default' is True, there will be no ordering in the resulting
      query (not even the model's default).



   .. py:method:: set_group_by(allow_aliases=True)

      Expand the GROUP BY clause required by the query.

      This will usually be the set of all non-aggregate fields in the
      return data. If the database backend supports grouping by the
      primary key, and the query would be equivalent, the optimization
      will be made automatically.



   .. py:method:: add_select_related(fields)

      Set up the select_related data structure so that we only select
      certain related models (as opposed to all models, when
      self.select_related=True).



   .. py:method:: add_extra(select, select_params, where, params, tables, order_by)

      Add data to the various extra_* attributes for user-created additions
      to the query.



   .. py:method:: clear_deferred_loading()

      Remove any fields from the deferred loading set.



   .. py:method:: add_deferred_loading(field_names)

      Add the given list of model field names to the set of fields to
      exclude from loading from the database when automatic column selection
      is done. Add the new field names to any existing field names that
      are deferred (or removed from any existing field names that are marked
      as the only ones for immediate loading).



   .. py:method:: add_immediate_loading(field_names)

      Add the given list of model field names to the set of fields to
      retrieve when the SQL is executed ("immediate loading" fields). The
      field names replace any existing immediate loading field names. If
      there are field names already specified for deferred loading, remove
      those names from the new field_names before storing the new names
      for immediate loading. (That is, immediate loading overrides any
      existing immediate values, but respects existing deferrals.)



   .. py:method:: set_annotation_mask(names)

      Set the mask of annotations that will be returned by the SELECT.



   .. py:method:: append_annotation_mask(names)


   .. py:method:: set_extra_mask(names)

      Set the mask of extra select items that will be returned by SELECT.
      Don't remove them from the Query since they might be used later.



   .. py:method:: set_values(fields)


   .. py:property:: annotation_select

      Return the dictionary of aggregate columns that are not masked and
      should be used in the SELECT clause. Cache this result for performance.


   .. py:property:: extra_select


   .. py:method:: trim_start(names_with_path)

      Trim joins from the start of the join path. The candidates for trim
      are the PathInfos in names_with_path structure that are m2m joins.

      Also set the select column so the start matches the join.

      This method is meant to be used for generating the subquery joins &
      cols in split_exclude().

      Return a lookup usable for doing outerq.filter(lookup=self) and a
      boolean indicating if the joins in the prefix contain a LEFT OUTER join.
      _



   .. py:method:: is_nullable(field)

      Check if the given field should be treated as nullable.

      Some backends treat '' as null and Django treats such fields as
      nullable for those backends. In such situations field.null can be
      False even if we should treat the field as nullable.



