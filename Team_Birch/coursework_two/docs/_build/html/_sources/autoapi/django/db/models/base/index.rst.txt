django.db.models.base
=====================

.. py:module:: django.db.models.base


Attributes
----------

.. autoapisummary::

   django.db.models.base.DEFERRED


Classes
-------

.. autoapisummary::

   django.db.models.base.Deferred
   django.db.models.base.ModelBase
   django.db.models.base.ModelStateFieldsCacheDescriptor
   django.db.models.base.ModelState
   django.db.models.base.Model


Functions
---------

.. autoapisummary::

   django.db.models.base.subclass_exception
   django.db.models.base.method_set_order
   django.db.models.base.method_get_order
   django.db.models.base.make_foreign_order_accessors
   django.db.models.base.model_unpickle


Module Contents
---------------

.. py:class:: Deferred

.. py:data:: DEFERRED

.. py:function:: subclass_exception(name, bases, module, attached_to)

   Create exception subclass. Used by ModelBase below.

   The exception is created in a way that allows it to be pickled, assuming
   that the returned exception class will be added as an attribute to the
   'attached_to' class.


.. py:class:: ModelBase

   Bases: :py:obj:`type`


   Metaclass for all models.


   .. py:method:: add_to_class(name, value)


.. py:class:: ModelStateFieldsCacheDescriptor

.. py:class:: ModelState

   Store model instance state.


   .. py:attribute:: db
      :value: None



   .. py:attribute:: adding
      :value: True



   .. py:attribute:: fields_cache


.. py:class:: Model(*args, **kwargs)

   Bases: :py:obj:`django.db.models.utils.AltersData`


   Make subclasses preserve the alters_data attribute on overridden methods.


   .. py:method:: from_db(db, field_names, values)
      :classmethod:



   .. py:attribute:: pk


   .. py:method:: get_deferred_fields()

      Return a set containing names of deferred fields for this instance.



   .. py:method:: refresh_from_db(using=None, fields=None)

      Reload field values from the database.

      By default, the reloading happens from the database this instance was
      loaded from, or by the read router if this instance wasn't loaded from
      any database. The using parameter will override the default.

      Fields can be used to specify which fields to reload. The fields
      should be an iterable of field attnames. If fields is None, then
      all non-deferred fields are reloaded.

      When accessing deferred fields of an instance, the deferred loading
      of the field will call this method.



   .. py:method:: arefresh_from_db(using=None, fields=None)
      :async:



   .. py:method:: serializable_value(field_name)

      Return the value of the field name for this instance. If the field is
      a foreign key, return the id value instead of the object. If there's
      no Field object with this name on the model, return the model
      attribute's value.

      Used to serialize a field's value (in the serializer, or form output,
      for example). Normally, you would just access the attribute directly
      and not use this method.



   .. py:method:: save(force_insert=False, force_update=False, using=None, update_fields=None)

      Save the current instance. Override this in a subclass if you want to
      control the saving process.

      The 'force_insert' and 'force_update' parameters can be used to insist
      that the "save" must be an SQL insert or update (or equivalent for
      non-SQL backends), respectively. Normally, they should not be set.



   .. py:method:: asave(force_insert=False, force_update=False, using=None, update_fields=None)
      :async:



   .. py:method:: save_base(raw=False, force_insert=False, force_update=False, using=None, update_fields=None)

      Handle the parts of saving which should be done only once per save,
      yet need to be done in raw saves, too. This includes some sanity
      checks and signal sending.

      The 'raw' argument is telling save_base not to save any parent
      models and not to do any changes to the values before save. This
      is used by fixture loading.



   .. py:method:: delete(using=None, keep_parents=False)


   .. py:method:: adelete(using=None, keep_parents=False)
      :async:



   .. py:method:: prepare_database_save(field)


   .. py:method:: clean()

      Hook for doing any extra model-wide validation after clean() has been
      called on every field by self.clean_fields. Any ValidationError raised
      by this method will not be associated with a particular field; it will
      have a special-case association with the field defined by NON_FIELD_ERRORS.



   .. py:method:: validate_unique(exclude=None)

      Check unique constraints on the model and raise ValidationError if any
      failed.



   .. py:method:: date_error_message(lookup_type, field_name, unique_for)


   .. py:method:: unique_error_message(model_class, unique_check)


   .. py:method:: get_constraints()


   .. py:method:: validate_constraints(exclude=None)


   .. py:method:: full_clean(exclude=None, validate_unique=True, validate_constraints=True)

      Call clean_fields(), clean(), validate_unique(), and
      validate_constraints() on the model. Raise a ValidationError for any
      errors that occur.



   .. py:method:: clean_fields(exclude=None)

      Clean all fields and raise a ValidationError containing a dict
      of all validation errors if any occur.



   .. py:method:: check(**kwargs)
      :classmethod:



.. py:function:: method_set_order(self, ordered_obj, id_list, using=None)

.. py:function:: method_get_order(self, ordered_obj)

.. py:function:: make_foreign_order_accessors(model, related_model)

.. py:function:: model_unpickle(model_id)

   Used to unpickle Model subclasses with deferred fields.


