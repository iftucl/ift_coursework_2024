django.utils.decorators
=======================

.. py:module:: django.utils.decorators

.. autoapi-nested-parse::

   Functions that help with dynamically creating decorators for views.



Classes
-------

.. autoapisummary::

   django.utils.decorators.classonlymethod


Functions
---------

.. autoapisummary::

   django.utils.decorators.method_decorator
   django.utils.decorators.decorator_from_middleware_with_args
   django.utils.decorators.decorator_from_middleware
   django.utils.decorators.make_middleware_decorator
   django.utils.decorators.sync_and_async_middleware
   django.utils.decorators.sync_only_middleware
   django.utils.decorators.async_only_middleware


Module Contents
---------------

.. py:class:: classonlymethod

   Bases: :py:obj:`classmethod`


   classmethod(function) -> method

   Convert a function to be a class method.

   A class method receives the class as implicit first argument,
   just like an instance method receives the instance.
   To declare a class method, use this idiom:

     class C:
         @classmethod
         def f(cls, arg1, arg2, argN):
             ...

   It can be called either on the class (e.g. C.f()) or on an instance
   (e.g. C().f()).  The instance is ignored except for its class.
   If a class method is called for a derived class, the derived class
   object is passed as the implied first argument.

   Class methods are different than C++ or Java static methods.
   If you want those, see the staticmethod builtin.


.. py:function:: method_decorator(decorator, name='')

   Convert a function decorator into a method decorator


.. py:function:: decorator_from_middleware_with_args(middleware_class)

   Like decorator_from_middleware, but return a function
   that accepts the arguments to be passed to the middleware_class.
   Use like::

        cache_page = decorator_from_middleware_with_args(CacheMiddleware)
        # ...

        @cache_page(3600)
        def my_view(request):
            # ...


.. py:function:: decorator_from_middleware(middleware_class)

   Given a middleware class (not an instance), return a view decorator. This
   lets you use middleware functionality on a per-view basis. The middleware
   is created with no params passed.


.. py:function:: make_middleware_decorator(middleware_class)

.. py:function:: sync_and_async_middleware(func)

   Mark a middleware factory as returning a hybrid middleware supporting both
   types of request.


.. py:function:: sync_only_middleware(func)

   Mark a middleware factory as returning a sync middleware.
   This is the default.


.. py:function:: async_only_middleware(func)

   Mark a middleware factory as returning an async middleware.


