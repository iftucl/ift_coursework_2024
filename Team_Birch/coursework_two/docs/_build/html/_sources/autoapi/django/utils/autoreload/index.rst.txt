django.utils.autoreload
=======================

.. py:module:: django.utils.autoreload


Attributes
----------

.. autoapisummary::

   django.utils.autoreload.autoreload_started
   django.utils.autoreload.file_changed
   django.utils.autoreload.DJANGO_AUTORELOAD_ENV
   django.utils.autoreload.logger
   django.utils.autoreload.termios
   django.utils.autoreload.pywatchman


Exceptions
----------

.. autoapisummary::

   django.utils.autoreload.WatchmanUnavailable


Classes
-------

.. autoapisummary::

   django.utils.autoreload.BaseReloader
   django.utils.autoreload.StatReloader
   django.utils.autoreload.WatchmanReloader


Functions
---------

.. autoapisummary::

   django.utils.autoreload.is_django_module
   django.utils.autoreload.is_django_path
   django.utils.autoreload.check_errors
   django.utils.autoreload.raise_last_exception
   django.utils.autoreload.ensure_echo_on
   django.utils.autoreload.iter_all_python_module_files
   django.utils.autoreload.iter_modules_and_files
   django.utils.autoreload.common_roots
   django.utils.autoreload.sys_path_directories
   django.utils.autoreload.get_child_arguments
   django.utils.autoreload.trigger_reload
   django.utils.autoreload.restart_with_reloader
   django.utils.autoreload.get_reloader
   django.utils.autoreload.start_django
   django.utils.autoreload.run_with_reloader


Module Contents
---------------

.. py:data:: autoreload_started

.. py:data:: file_changed

.. py:data:: DJANGO_AUTORELOAD_ENV
   :value: 'RUN_MAIN'


.. py:data:: logger

.. py:data:: termios
   :value: None


.. py:data:: pywatchman
   :value: None


.. py:function:: is_django_module(module)

   Return True if the given module is nested under Django.


.. py:function:: is_django_path(path)

   Return True if the given file path is nested under Django.


.. py:function:: check_errors(fn)

.. py:function:: raise_last_exception()

.. py:function:: ensure_echo_on()

   Ensure that echo mode is enabled. Some tools such as PDB disable
   it which causes usability issues after reload.


.. py:function:: iter_all_python_module_files()

.. py:function:: iter_modules_and_files(modules, extra_files)

   Iterate through all modules needed to be watched.


.. py:function:: common_roots(paths)

   Return a tuple of common roots that are shared between the given paths.
   File system watchers operate on directories and aren't cheap to create.
   Try to find the minimum set of directories to watch that encompass all of
   the files that need to be watched.


.. py:function:: sys_path_directories()

   Yield absolute directories from sys.path, ignoring entries that don't
   exist.


.. py:function:: get_child_arguments()

   Return the executable. This contains a workaround for Windows if the
   executable is reported to not have the .exe extension which can cause bugs
   on reloading.


.. py:function:: trigger_reload(filename)

.. py:function:: restart_with_reloader()

.. py:class:: BaseReloader

   .. py:attribute:: extra_files


   .. py:attribute:: directory_globs


   .. py:method:: watch_dir(path, glob)


   .. py:method:: watched_files(include_globs=True)

      Yield all files that need to be watched, including module files and
      files within globs.



   .. py:method:: wait_for_apps_ready(app_reg, django_main_thread)

      Wait until Django reports that the apps have been loaded. If the given
      thread has terminated before the apps are ready, then a SyntaxError or
      other non-recoverable error has been raised. In that case, stop waiting
      for the apps_ready event and continue processing.

      Return True if the thread is alive and the ready event has been
      triggered, or False if the thread is terminated while waiting for the
      event.



   .. py:method:: run(django_main_thread)


   .. py:method:: run_loop()


   .. py:method:: tick()
      :abstractmethod:


      This generator is called in a loop from run_loop. It's important that
      the method takes care of pausing or otherwise waiting for a period of
      time. This split between run_loop() and tick() is to improve the
      testability of the reloader implementations by decoupling the work they
      do from the loop.



   .. py:method:: check_availability()
      :classmethod:

      :abstractmethod:



   .. py:method:: notify_file_changed(path)


   .. py:property:: should_stop


   .. py:method:: stop()


.. py:class:: StatReloader

   Bases: :py:obj:`BaseReloader`


   .. py:attribute:: SLEEP_TIME
      :value: 1



   .. py:method:: tick()

      This generator is called in a loop from run_loop. It's important that
      the method takes care of pausing or otherwise waiting for a period of
      time. This split between run_loop() and tick() is to improve the
      testability of the reloader implementations by decoupling the work they
      do from the loop.



   .. py:method:: snapshot_files()


   .. py:method:: check_availability()
      :classmethod:



.. py:exception:: WatchmanUnavailable

   Bases: :py:obj:`RuntimeError`


   Unspecified run-time error.


.. py:class:: WatchmanReloader

   Bases: :py:obj:`BaseReloader`


   .. py:attribute:: roots


   .. py:attribute:: processed_request


   .. py:attribute:: client_timeout


   .. py:method:: client()


   .. py:method:: watched_roots(watched_files)


   .. py:method:: update_watches()


   .. py:method:: request_processed(**kwargs)


   .. py:method:: tick()

      This generator is called in a loop from run_loop. It's important that
      the method takes care of pausing or otherwise waiting for a period of
      time. This split between run_loop() and tick() is to improve the
      testability of the reloader implementations by decoupling the work they
      do from the loop.



   .. py:method:: stop()


   .. py:method:: check_server_status(inner_ex=None)

      Return True if the server is available.



   .. py:method:: check_availability()
      :classmethod:



.. py:function:: get_reloader()

   Return the most suitable reloader for this environment.


.. py:function:: start_django(reloader, main_func, *args, **kwargs)

.. py:function:: run_with_reloader(main_func, *args, **kwargs)

