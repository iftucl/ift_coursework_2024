django.template.base
====================

.. py:module:: django.template.base

.. autoapi-nested-parse::

   This is the Django template system.

   How it works:

   The Lexer.tokenize() method converts a template string (i.e., a string
   containing markup with custom template tags) to tokens, which can be either
   plain text (TokenType.TEXT), variables (TokenType.VAR), or block statements
   (TokenType.BLOCK).

   The Parser() class takes a list of tokens in its constructor, and its parse()
   method returns a compiled template -- which is, under the hood, a list of
   Node objects.

   Each Node is responsible for creating some sort of output -- e.g. simple text
   (TextNode), variable values in a given context (VariableNode), results of basic
   logic (IfNode), results of looping (ForNode), or anything else. The core Node
   types are TextNode, VariableNode, IfNode and ForNode, but plugin modules can
   define their own custom node types.

   Each Node has a render() method, which takes a Context and returns a string of
   the rendered node. For example, the render() method of a Variable Node returns
   the variable's value as a string. The render() method of a ForNode returns the
   rendered output of whatever was inside the loop, recursively.

   The Template class is a convenient wrapper that takes care of template
   compilation and rendering.

   Usage:

   The only thing you should ever use directly in this file is the Template class.
   Create a compiled template object with a template_string, then call render()
   with a context. In the compilation stage, the TemplateSyntaxError exception
   will be raised if the template doesn't have proper syntax.

   Sample code:

   >>> from django import template
   >>> s = '<html>{% if test %}<h1>{{ varvalue }}</h1>{% endif %}</html>'
   >>> t = template.Template(s)

   (t is now a compiled template, and its render() method can be called multiple
   times with multiple contexts)

   >>> c = template.Context({'test':True, 'varvalue': 'Hello'})
   >>> t.render(c)
   '<html><h1>Hello</h1></html>'
   >>> c = template.Context({'test':False, 'varvalue': 'Hello'})
   >>> t.render(c)
   '<html></html>'



Attributes
----------

.. autoapisummary::

   django.template.base.FILTER_SEPARATOR
   django.template.base.FILTER_ARGUMENT_SEPARATOR
   django.template.base.VARIABLE_ATTRIBUTE_SEPARATOR
   django.template.base.BLOCK_TAG_START
   django.template.base.BLOCK_TAG_END
   django.template.base.VARIABLE_TAG_START
   django.template.base.VARIABLE_TAG_END
   django.template.base.COMMENT_TAG_START
   django.template.base.COMMENT_TAG_END
   django.template.base.SINGLE_BRACE_START
   django.template.base.SINGLE_BRACE_END
   django.template.base.UNKNOWN_SOURCE
   django.template.base.tag_re
   django.template.base.logger
   django.template.base.constant_string
   django.template.base.constant_string
   django.template.base.filter_raw_string
   django.template.base.filter_re
   django.template.base.kwarg_re


Exceptions
----------

.. autoapisummary::

   django.template.base.VariableDoesNotExist


Classes
-------

.. autoapisummary::

   django.template.base.TokenType
   django.template.base.Origin
   django.template.base.Template
   django.template.base.Token
   django.template.base.Lexer
   django.template.base.DebugLexer
   django.template.base.Parser
   django.template.base.FilterExpression
   django.template.base.Variable
   django.template.base.Node
   django.template.base.NodeList
   django.template.base.TextNode
   django.template.base.VariableNode


Functions
---------

.. autoapisummary::

   django.template.base.linebreak_iter
   django.template.base.render_value_in_context
   django.template.base.token_kwargs


Module Contents
---------------

.. py:data:: FILTER_SEPARATOR
   :value: '|'


.. py:data:: FILTER_ARGUMENT_SEPARATOR
   :value: ':'


.. py:data:: VARIABLE_ATTRIBUTE_SEPARATOR
   :value: '.'


.. py:data:: BLOCK_TAG_START
   :value: '{%'


.. py:data:: BLOCK_TAG_END
   :value: '%}'


.. py:data:: VARIABLE_TAG_START
   :value: '{{'


.. py:data:: VARIABLE_TAG_END
   :value: '}}'


.. py:data:: COMMENT_TAG_START
   :value: '{#'


.. py:data:: COMMENT_TAG_END
   :value: '#}'


.. py:data:: SINGLE_BRACE_START
   :value: '{'


.. py:data:: SINGLE_BRACE_END
   :value: '}'


.. py:data:: UNKNOWN_SOURCE
   :value: '<unknown source>'


.. py:data:: tag_re

.. py:data:: logger

.. py:class:: TokenType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:attribute:: TEXT
      :value: 0



   .. py:attribute:: VAR
      :value: 1



   .. py:attribute:: BLOCK
      :value: 2



   .. py:attribute:: COMMENT
      :value: 3



.. py:exception:: VariableDoesNotExist(msg, params=())

   Bases: :py:obj:`Exception`


   Common base class for all non-exit exceptions.


   .. py:attribute:: msg


   .. py:attribute:: params
      :value: ()



.. py:class:: Origin(name, template_name=None, loader=None)

   .. py:attribute:: name


   .. py:attribute:: template_name
      :value: None



   .. py:attribute:: loader
      :value: None



   .. py:property:: loader_name


.. py:class:: Template(template_string, origin=None, name=None, engine=None)

   .. py:attribute:: name
      :value: None



   .. py:attribute:: origin
      :value: None



   .. py:attribute:: engine
      :value: None



   .. py:attribute:: source
      :value: ''



   .. py:attribute:: nodelist


   .. py:method:: render(context)

      Display stage -- can be called many times



   .. py:method:: compile_nodelist()

      Parse and compile the template source into a nodelist. If debug
      is True and an exception occurs during parsing, the exception is
      annotated with contextual line information where it occurred in the
      template source.



   .. py:method:: get_exception_info(exception, token)

      Return a dictionary containing contextual line information of where
      the exception occurred in the template. The following information is
      provided:

      message
          The message of the exception raised.

      source_lines
          The lines before, after, and including the line the exception
          occurred on.

      line
          The line number the exception occurred on.

      before, during, after
          The line the exception occurred on split into three parts:
          1. The content before the token that raised the error.
          2. The token that raised the error.
          3. The content after the token that raised the error.

      total
          The number of lines in source_lines.

      top
          The line number where source_lines starts.

      bottom
          The line number where source_lines ends.

      start
          The start position of the token in the template source.

      end
          The end position of the token in the template source.



.. py:function:: linebreak_iter(template_source)

.. py:class:: Token(token_type, contents, position=None, lineno=None)

   .. py:attribute:: lineno
      :value: None



   .. py:attribute:: position
      :value: None



   .. py:method:: split_contents()


.. py:class:: Lexer(template_string)

   .. py:attribute:: template_string


   .. py:attribute:: verbatim
      :value: False



   .. py:method:: tokenize()

      Return a list of tokens from a given template_string.



   .. py:method:: create_token(token_string, position, lineno, in_tag)

      Convert the given token string into a new Token object and return it.
      If in_tag is True, we are processing something that matched a tag,
      otherwise it should be treated as a literal string.



.. py:class:: DebugLexer(template_string)

   Bases: :py:obj:`Lexer`


   .. py:method:: tokenize()

      Split a template string into tokens and annotates each token with its
      start and end position in the source. This is slower than the default
      lexer so only use it when debug is True.



.. py:class:: Parser(tokens, libraries=None, builtins=None, origin=None)

   .. py:attribute:: tokens


   .. py:attribute:: tags


   .. py:attribute:: filters


   .. py:attribute:: command_stack
      :value: []



   .. py:attribute:: libraries
      :value: None



   .. py:attribute:: origin
      :value: None



   .. py:method:: parse(parse_until=None)

      Iterate through the parser tokens and compiles each one into a node.

      If parse_until is provided, parsing will stop once one of the
      specified tokens has been reached. This is formatted as a list of
      tokens, e.g. ['elif', 'else', 'endif']. If no matching token is
      reached, raise an exception with the unclosed block tag details.



   .. py:method:: skip_past(endtag)


   .. py:method:: extend_nodelist(nodelist, node, token)


   .. py:method:: error(token, e)

      Return an exception annotated with the originating token. Since the
      parser can be called recursively, check if a token is already set. This
      ensures the innermost token is highlighted if an exception occurs,
      e.g. a compile error within the body of an if statement.



   .. py:method:: invalid_block_tag(token, command, parse_until=None)


   .. py:method:: unclosed_block_tag(parse_until)


   .. py:method:: next_token()


   .. py:method:: prepend_token(token)


   .. py:method:: delete_first_token()


   .. py:method:: add_library(lib)


   .. py:method:: compile_filter(token)

      Convenient wrapper for FilterExpression



   .. py:method:: find_filter(filter_name)


.. py:data:: constant_string

.. py:data:: constant_string

.. py:data:: filter_raw_string

.. py:data:: filter_re

.. py:class:: FilterExpression(token, parser)

   Parse a variable token and its optional filters (all as a single string),
   and return a list of tuples of the filter name and arguments.
   Sample::

       >>> token = 'variable|default:"Default value"|date:"Y-m-d"'
       >>> p = Parser('')
       >>> fe = FilterExpression(token, p)
       >>> len(fe.filters)
       2
       >>> fe.var
       <Variable: 'variable'>


   .. py:attribute:: token


   .. py:attribute:: filters
      :value: []



   .. py:attribute:: var
      :value: None



   .. py:attribute:: is_var


   .. py:method:: resolve(context, ignore_failures=False)


   .. py:method:: args_check(name, func, provided)
      :staticmethod:



.. py:class:: Variable(var)

   A template variable, resolvable against a given context. The variable may
   be a hard-coded string (if it begins and ends with single or double quote
   marks)::

       >>> c = {'article': {'section':'News'}}
       >>> Variable('article.section').resolve(c)
       'News'
       >>> Variable('article').resolve(c)
       {'section': 'News'}
       >>> class AClass: pass
       >>> c = AClass()
       >>> c.article = AClass()
       >>> c.article.section = 'News'

   (The example assumes VARIABLE_ATTRIBUTE_SEPARATOR is '.')


   .. py:attribute:: var


   .. py:attribute:: literal
      :value: None



   .. py:attribute:: lookups
      :value: None



   .. py:attribute:: translate
      :value: False



   .. py:attribute:: message_context
      :value: None



   .. py:method:: resolve(context)

      Resolve this variable against a given context.



.. py:class:: Node

   .. py:attribute:: must_be_first
      :value: False



   .. py:attribute:: child_nodelists
      :value: ('nodelist',)



   .. py:attribute:: token
      :value: None



   .. py:method:: render(context)

      Return the node rendered as a string.



   .. py:method:: render_annotated(context)

      Render the node. If debug is True and an exception occurs during
      rendering, the exception is annotated with contextual line information
      where it occurred in the template. For internal usage this method is
      preferred over using the render method directly.



   .. py:method:: get_nodes_by_type(nodetype)

      Return a list of all nodes (within this node and its nodelist)
      of the given type



.. py:class:: NodeList

   Bases: :py:obj:`list`


   Built-in mutable sequence.

   If no argument is given, the constructor creates a new empty list.
   The argument must be an iterable if specified.


   .. py:attribute:: contains_nontext
      :value: False



   .. py:method:: render(context)


   .. py:method:: get_nodes_by_type(nodetype)

      Return a list of all nodes of the given type



.. py:class:: TextNode(s)

   Bases: :py:obj:`Node`


   .. py:attribute:: child_nodelists
      :value: ()



   .. py:attribute:: s


   .. py:method:: render(context)

      Return the node rendered as a string.



   .. py:method:: render_annotated(context)

      Return the given value.

      The default implementation of this method handles exceptions raised
      during rendering, which is not necessary for text nodes.



.. py:function:: render_value_in_context(value, context)

   Convert any value to a string to become part of a rendered template. This
   means escaping, if required, and conversion to a string. If value is a
   string, it's expected to already be translated.


.. py:class:: VariableNode(filter_expression)

   Bases: :py:obj:`Node`


   .. py:attribute:: child_nodelists
      :value: ()



   .. py:attribute:: filter_expression


   .. py:method:: render(context)

      Return the node rendered as a string.



.. py:data:: kwarg_re

.. py:function:: token_kwargs(bits, parser, support_legacy=False)

   Parse token keyword arguments and return a dictionary of the arguments
   retrieved from the ``bits`` token list.

   `bits` is a list containing the remainder of the token (split by spaces)
   that is to be checked for arguments. Valid arguments are removed from this
   list.

   `support_legacy` - if True, the legacy format ``1 as foo`` is accepted.
   Otherwise, only the standard ``foo=1`` format is allowed.

   There is no requirement for all remaining token ``bits`` to be keyword
   arguments, so return the dictionary as soon as an invalid argument format
   is reached.


