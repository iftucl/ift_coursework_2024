django.template.loader_tags
===========================

.. py:module:: django.template.loader_tags


Attributes
----------

.. autoapisummary::

   django.template.loader_tags.register
   django.template.loader_tags.BLOCK_CONTEXT_KEY


Classes
-------

.. autoapisummary::

   django.template.loader_tags.BlockContext
   django.template.loader_tags.BlockNode
   django.template.loader_tags.ExtendsNode
   django.template.loader_tags.IncludeNode


Functions
---------

.. autoapisummary::

   django.template.loader_tags.do_block
   django.template.loader_tags.construct_relative_path
   django.template.loader_tags.do_extends
   django.template.loader_tags.do_include


Module Contents
---------------

.. py:data:: register

.. py:data:: BLOCK_CONTEXT_KEY
   :value: 'block_context'


.. py:class:: BlockContext

   .. py:attribute:: blocks


   .. py:method:: add_blocks(blocks)


   .. py:method:: pop(name)


   .. py:method:: push(name, block)


   .. py:method:: get_block(name)


.. py:class:: BlockNode(name, nodelist, parent=None)

   Bases: :py:obj:`django.template.base.Node`


   .. py:method:: render(context)


   .. py:method:: super()


.. py:class:: ExtendsNode(nodelist, parent_name, template_dirs=None)

   Bases: :py:obj:`django.template.base.Node`


   .. py:attribute:: must_be_first
      :value: True



   .. py:attribute:: context_key
      :value: 'extends_context'



   .. py:attribute:: nodelist


   .. py:attribute:: parent_name


   .. py:attribute:: template_dirs
      :value: None



   .. py:attribute:: blocks


   .. py:method:: find_template(template_name, context)

      This is a wrapper around engine.find_template(). A history is kept in
      the render_context attribute between successive extends calls and
      passed as the skip argument. This enables extends to work recursively
      without extending the same template twice.



   .. py:method:: get_parent(context)


   .. py:method:: render(context)


.. py:class:: IncludeNode(template, *args, extra_context=None, isolated_context=False, **kwargs)

   Bases: :py:obj:`django.template.base.Node`


   .. py:attribute:: context_key
      :value: '__include_context'



   .. py:attribute:: template


   .. py:attribute:: extra_context


   .. py:attribute:: isolated_context
      :value: False



   .. py:method:: render(context)

      Render the specified template and context. Cache the template object
      in render_context to avoid reparsing and loading when used in a for
      loop.



.. py:function:: do_block(parser, token)

   Define a block that can be overridden by child templates.


.. py:function:: construct_relative_path(current_template_name, relative_name)

   Convert a relative path (starting with './' or '../') to the full template
   name based on the current_template_name.


.. py:function:: do_extends(parser, token)

   Signal that this template extends a parent template.

   This tag may be used in two ways: ``{% extends "base" %}`` (with quotes)
   uses the literal value "base" as the name of the parent template to extend,
   or ``{% extends variable %}`` uses the value of ``variable`` as either the
   name of the parent template to extend (if it evaluates to a string) or as
   the parent template itself (if it evaluates to a Template object).


.. py:function:: do_include(parser, token)

   Load a template and render it with the current context. You can pass
   additional context using keyword arguments.

   Example::

       {% include "foo/some_include" %}
       {% include "foo/some_include" with bar="BAZZ!" baz="BING!" %}

   Use the ``only`` argument to exclude the current context when rendering
   the included template::

       {% include "foo/some_include" only %}
       {% include "foo/some_include" with bar="1" only %}


