jinja2.optimizer
================

.. py:module:: jinja2.optimizer

.. autoapi-nested-parse::

   The optimizer tries to constant fold expressions and modify the AST
   in place so that it should be faster to evaluate.

   Because the AST does not contain all the scoping information and the
   compiler has to find that out, we cannot do all the optimizations we
   want. For example, loop unrolling doesn't work because unrolled loops
   would have a different scope. The solution would be a second syntax tree
   that stored the scoping rules.



Classes
-------

.. autoapisummary::

   jinja2.optimizer.Optimizer


Functions
---------

.. autoapisummary::

   jinja2.optimizer.optimize


Module Contents
---------------

.. py:function:: optimize(node: jinja2.nodes.Node, environment: jinja2.environment.Environment) -> jinja2.nodes.Node

   The context hint can be used to perform an static optimization
   based on the context given.


.. py:class:: Optimizer(environment: Optional[Environment])

   Bases: :py:obj:`jinja2.visitor.NodeTransformer`


   Walks the abstract syntax tree and allows modifications of nodes.

   The `NodeTransformer` will walk the AST and use the return value of the
   visitor functions to replace or remove the old node.  If the return
   value of the visitor function is `None` the node will be removed
   from the previous location otherwise it's replaced with the return
   value.  The return value may be the original node in which case no
   replacement takes place.


   .. py:attribute:: environment


   .. py:method:: generic_visit(node: jinja2.nodes.Node, *args: Any, **kwargs: Any) -> jinja2.nodes.Node

      Called if no explicit visitor function exists for a node.



