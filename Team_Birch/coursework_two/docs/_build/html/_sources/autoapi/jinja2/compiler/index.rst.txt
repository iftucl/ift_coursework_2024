jinja2.compiler
===============

.. py:module:: jinja2.compiler

.. autoapi-nested-parse::

   Compiles nodes from the parser into Python code.



Attributes
----------

.. autoapisummary::

   jinja2.compiler.F
   jinja2.compiler.operators


Exceptions
----------

.. autoapisummary::

   jinja2.compiler.VisitorExit
   jinja2.compiler.CompilerExit


Classes
-------

.. autoapisummary::

   jinja2.compiler.MacroRef
   jinja2.compiler.Frame
   jinja2.compiler.DependencyFinderVisitor
   jinja2.compiler.UndeclaredNameVisitor
   jinja2.compiler.CodeGenerator


Functions
---------

.. autoapisummary::

   jinja2.compiler.optimizeconst
   jinja2.compiler.generate
   jinja2.compiler.has_safe_repr
   jinja2.compiler.find_undeclared


Module Contents
---------------

.. py:data:: F

.. py:data:: operators

.. py:function:: optimizeconst(f: F) -> F

.. py:function:: generate(node: jinja2.nodes.Template, environment: jinja2.environment.Environment, name: Optional[str], filename: Optional[str], stream: Optional[TextIO] = None, defer_init: bool = False, optimized: bool = True) -> Optional[str]

   Generate the python source for a node tree.


.. py:function:: has_safe_repr(value: Any) -> bool

   Does the node have a safe representation?


.. py:function:: find_undeclared(nodes: Iterable[find_undeclared.nodes], names: Iterable[str]) -> Set[str]

   Check if the names passed are accessed undeclared.  The return value
   is a set of all the undeclared names from the sequence of names found.


.. py:class:: MacroRef(node: Union[jinja2.nodes.Macro, jinja2.nodes.CallBlock])

   .. py:attribute:: node


   .. py:attribute:: accesses_caller
      :value: False



   .. py:attribute:: accesses_kwargs
      :value: False



   .. py:attribute:: accesses_varargs
      :value: False



.. py:class:: Frame(eval_ctx: jinja2.nodes.EvalContext, parent: Optional[Frame] = None, level: Optional[int] = None)

   Holds compile time information for us.


   .. py:attribute:: eval_ctx


   .. py:attribute:: parent
      :value: None



   .. py:attribute:: toplevel
      :value: False



   .. py:attribute:: rootlevel
      :value: False



   .. py:attribute:: loop_frame
      :value: False



   .. py:attribute:: block_frame
      :value: False



   .. py:attribute:: soft_frame
      :value: False



   .. py:method:: copy() -> typing_extensions.Self

      Create a copy of the current one.



   .. py:method:: inner(isolated: bool = False) -> Frame

      Return an inner frame.



   .. py:method:: soft() -> typing_extensions.Self

      Return a soft frame.  A soft frame may not be modified as
      standalone thing as it shares the resources with the frame it
      was created of, but it's not a rootlevel frame any longer.

      This is only used to implement if-statements and conditional
      expressions.



.. py:exception:: VisitorExit

   Bases: :py:obj:`RuntimeError`


   Exception used by the `UndeclaredNameVisitor` to signal a stop.


.. py:class:: DependencyFinderVisitor

   Bases: :py:obj:`jinja2.visitor.NodeVisitor`


   A visitor that collects filter and test calls.


   .. py:attribute:: filters
      :type:  Set[str]


   .. py:attribute:: tests
      :type:  Set[str]


   .. py:method:: visit_Filter(node: jinja2.nodes.Filter) -> None


   .. py:method:: visit_Test(node: jinja2.nodes.Test) -> None


   .. py:method:: visit_Block(node: jinja2.nodes.Block) -> None

      Stop visiting at blocks.



.. py:class:: UndeclaredNameVisitor(names: Iterable[str])

   Bases: :py:obj:`jinja2.visitor.NodeVisitor`


   A visitor that checks if a name is accessed without being
   declared.  This is different from the frame visitor as it will
   not stop at closure frames.


   .. py:attribute:: names


   .. py:attribute:: undeclared
      :type:  Set[str]


   .. py:method:: visit_Name(node: jinja2.nodes.Name) -> None


   .. py:method:: visit_Block(node: jinja2.nodes.Block) -> None

      Stop visiting a blocks.



.. py:exception:: CompilerExit

   Bases: :py:obj:`Exception`


   Raised if the compiler encountered a situation where it just
   doesn't make sense to further process the code.  Any block that
   raises such an exception is not further processed.


.. py:class:: CodeGenerator(environment: jinja2.environment.Environment, name: Optional[str], filename: Optional[str], stream: Optional[TextIO] = None, defer_init: bool = False, optimized: bool = True)

   Bases: :py:obj:`jinja2.visitor.NodeVisitor`


   Walks the abstract syntax tree and call visitor functions for every
   node found.  The visitor functions may return values which will be
   forwarded by the `visit` method.

   Per default the visitor functions for the nodes are ``'visit_'`` +
   class name of the node.  So a `TryFinally` node visit function would
   be `visit_TryFinally`.  This behavior can be changed by overriding
   the `get_visitor` function.  If no visitor function exists for a node
   (return value `None`) the `generic_visit` visitor is used instead.


   .. py:attribute:: environment


   .. py:attribute:: name


   .. py:attribute:: filename


   .. py:attribute:: stream
      :value: None



   .. py:attribute:: created_block_context
      :value: False



   .. py:attribute:: defer_init
      :value: False



   .. py:attribute:: optimizer
      :type:  Optional[jinja2.optimizer.Optimizer]
      :value: None



   .. py:attribute:: import_aliases
      :type:  Dict[str, str]


   .. py:attribute:: blocks
      :type:  Dict[str, jinja2.nodes.Block]


   .. py:attribute:: extends_so_far
      :value: 0



   .. py:attribute:: has_known_extends
      :value: False



   .. py:attribute:: code_lineno
      :value: 1



   .. py:attribute:: tests
      :type:  Dict[str, str]


   .. py:attribute:: filters
      :type:  Dict[str, str]


   .. py:attribute:: debug_info
      :type:  List[Tuple[int, int]]
      :value: []



   .. py:property:: optimized
      :type: bool



   .. py:method:: fail(msg: str, lineno: int) -> typing_extensions.NoReturn

      Fail with a :exc:`TemplateAssertionError`.



   .. py:method:: temporary_identifier() -> str

      Get a new unique identifier.



   .. py:method:: buffer(frame: Frame) -> None

      Enable buffering for the frame from that point onwards.



   .. py:method:: return_buffer_contents(frame: Frame, force_unescaped: bool = False) -> None

      Return the buffer contents of the frame.



   .. py:method:: indent() -> None

      Indent by one.



   .. py:method:: outdent(step: int = 1) -> None

      Outdent by step.



   .. py:method:: start_write(frame: Frame, node: Optional[jinja2.nodes.Node] = None) -> None

      Yield or write into the frame buffer.



   .. py:method:: end_write(frame: Frame) -> None

      End the writing process started by `start_write`.



   .. py:method:: simple_write(s: str, frame: Frame, node: Optional[jinja2.nodes.Node] = None) -> None

      Simple shortcut for start_write + write + end_write.



   .. py:method:: blockvisit(nodes: Iterable[CodeGenerator.blockvisit.nodes], frame: Frame) -> None

      Visit a list of nodes as block in a frame.  If the current frame
      is no buffer a dummy ``if 0: yield None`` is written automatically.



   .. py:method:: write(x: str) -> None

      Write a string into the output stream.



   .. py:method:: writeline(x: str, node: Optional[jinja2.nodes.Node] = None, extra: int = 0) -> None

      Combination of newline and write.



   .. py:method:: newline(node: Optional[jinja2.nodes.Node] = None, extra: int = 0) -> None

      Add one or more newlines before the next write.



   .. py:method:: signature(node: Union[jinja2.nodes.Call, jinja2.nodes.Filter, jinja2.nodes.Test], frame: Frame, extra_kwargs: Optional[Mapping[str, Any]] = None) -> None

      Writes a function call to the stream for the current node.
      A leading comma is added automatically.  The extra keyword
      arguments may not include python keywords otherwise a syntax
      error could occur.  The extra keyword arguments should be given
      as python dict.



   .. py:method:: pull_dependencies(nodes: Iterable[CodeGenerator.pull_dependencies.nodes]) -> None

      Find all filter and test names used in the template and
      assign them to variables in the compiled namespace. Checking
      that the names are registered with the environment is done when
      compiling the Filter and Test nodes. If the node is in an If or
      CondExpr node, the check is done at runtime instead.

      .. versionchanged:: 3.0
          Filters and tests in If and CondExpr nodes are checked at
          runtime instead of compile time.



   .. py:method:: enter_frame(frame: Frame) -> None


   .. py:method:: leave_frame(frame: Frame, with_python_scope: bool = False) -> None


   .. py:method:: choose_async(async_value: str = 'async ', sync_value: str = '') -> str


   .. py:method:: func(name: str) -> str


   .. py:method:: macro_body(node: Union[jinja2.nodes.Macro, jinja2.nodes.CallBlock], frame: Frame) -> Tuple[Frame, MacroRef]

      Dump the function def of a macro or call block.



   .. py:method:: macro_def(macro_ref: MacroRef, frame: Frame) -> None

      Dump the macro definition for the def created by macro_body.



   .. py:method:: position(node: jinja2.nodes.Node) -> str

      Return a human readable position for the node.



   .. py:method:: dump_local_context(frame: Frame) -> str


   .. py:method:: write_commons() -> None

      Writes a common preamble that is used by root and block functions.
      Primarily this sets up common local helpers and enforces a generator
      through a dead branch.



   .. py:method:: push_parameter_definitions(frame: Frame) -> None

      Pushes all parameter targets from the given frame into a local
      stack that permits tracking of yet to be assigned parameters.  In
      particular this enables the optimization from `visit_Name` to skip
      undefined expressions for parameters in macros as macros can reference
      otherwise unbound parameters.



   .. py:method:: pop_parameter_definitions() -> None

      Pops the current parameter definitions set.



   .. py:method:: mark_parameter_stored(target: str) -> None

      Marks a parameter in the current parameter definitions as stored.
      This will skip the enforced undefined checks.



   .. py:method:: push_context_reference(target: str) -> None


   .. py:method:: pop_context_reference() -> None


   .. py:method:: get_context_ref() -> str


   .. py:method:: get_resolve_func() -> str


   .. py:method:: derive_context(frame: Frame) -> str


   .. py:method:: parameter_is_undeclared(target: str) -> bool

      Checks if a given target is an undeclared parameter.



   .. py:method:: push_assign_tracking() -> None

      Pushes a new layer for assignment tracking.



   .. py:method:: pop_assign_tracking(frame: Frame) -> None

      Pops the topmost level for assignment tracking and updates the
      context variables if necessary.



   .. py:method:: visit_Template(node: jinja2.nodes.Template, frame: Optional[Frame] = None) -> None


   .. py:method:: visit_Block(node: jinja2.nodes.Block, frame: Frame) -> None

      Call a block and register it for the template.



   .. py:method:: visit_Extends(node: jinja2.nodes.Extends, frame: Frame) -> None

      Calls the extender.



   .. py:method:: visit_Include(node: jinja2.nodes.Include, frame: Frame) -> None

      Handles includes.



   .. py:method:: visit_Import(node: jinja2.nodes.Import, frame: Frame) -> None

      Visit regular imports.



   .. py:method:: visit_FromImport(node: jinja2.nodes.FromImport, frame: Frame) -> None

      Visit named imports.



   .. py:method:: visit_For(node: jinja2.nodes.For, frame: Frame) -> None


   .. py:method:: visit_If(node: jinja2.nodes.If, frame: Frame) -> None


   .. py:method:: visit_Macro(node: jinja2.nodes.Macro, frame: Frame) -> None


   .. py:method:: visit_CallBlock(node: jinja2.nodes.CallBlock, frame: Frame) -> None


   .. py:method:: visit_FilterBlock(node: jinja2.nodes.FilterBlock, frame: Frame) -> None


   .. py:method:: visit_With(node: jinja2.nodes.With, frame: Frame) -> None


   .. py:method:: visit_ExprStmt(node: jinja2.nodes.ExprStmt, frame: Frame) -> None


   .. py:method:: visit_Output(node: jinja2.nodes.Output, frame: Frame) -> None


   .. py:method:: visit_Assign(node: jinja2.nodes.Assign, frame: Frame) -> None


   .. py:method:: visit_AssignBlock(node: jinja2.nodes.AssignBlock, frame: Frame) -> None


   .. py:method:: visit_Name(node: jinja2.nodes.Name, frame: Frame) -> None


   .. py:method:: visit_NSRef(node: jinja2.nodes.NSRef, frame: Frame) -> None


   .. py:method:: visit_Const(node: jinja2.nodes.Const, frame: Frame) -> None


   .. py:method:: visit_TemplateData(node: jinja2.nodes.TemplateData, frame: Frame) -> None


   .. py:method:: visit_Tuple(node: jinja2.nodes.Tuple, frame: Frame) -> None


   .. py:method:: visit_List(node: jinja2.nodes.List, frame: Frame) -> None


   .. py:method:: visit_Dict(node: jinja2.nodes.Dict, frame: Frame) -> None


   .. py:attribute:: visit_Add


   .. py:attribute:: visit_Sub


   .. py:attribute:: visit_Mul


   .. py:attribute:: visit_Div


   .. py:attribute:: visit_FloorDiv


   .. py:attribute:: visit_Pow


   .. py:attribute:: visit_Mod


   .. py:attribute:: visit_And


   .. py:attribute:: visit_Or


   .. py:attribute:: visit_Pos


   .. py:attribute:: visit_Neg


   .. py:attribute:: visit_Not


   .. py:method:: visit_Concat(node: jinja2.nodes.Concat, frame: Frame) -> None


   .. py:method:: visit_Compare(node: jinja2.nodes.Compare, frame: Frame) -> None


   .. py:method:: visit_Operand(node: jinja2.nodes.Operand, frame: Frame) -> None


   .. py:method:: visit_Getattr(node: jinja2.nodes.Getattr, frame: Frame) -> None


   .. py:method:: visit_Getitem(node: jinja2.nodes.Getitem, frame: Frame) -> None


   .. py:method:: visit_Slice(node: jinja2.nodes.Slice, frame: Frame) -> None


   .. py:method:: visit_Filter(node: jinja2.nodes.Filter, frame: Frame) -> None


   .. py:method:: visit_Test(node: jinja2.nodes.Test, frame: Frame) -> None


   .. py:method:: visit_CondExpr(node: jinja2.nodes.CondExpr, frame: Frame) -> None


   .. py:method:: visit_Call(node: jinja2.nodes.Call, frame: Frame, forward_caller: bool = False) -> None


   .. py:method:: visit_Keyword(node: jinja2.nodes.Keyword, frame: Frame) -> None


   .. py:method:: visit_MarkSafe(node: jinja2.nodes.MarkSafe, frame: Frame) -> None


   .. py:method:: visit_MarkSafeIfAutoescape(node: jinja2.nodes.MarkSafeIfAutoescape, frame: Frame) -> None


   .. py:method:: visit_EnvironmentAttribute(node: jinja2.nodes.EnvironmentAttribute, frame: Frame) -> None


   .. py:method:: visit_ExtensionAttribute(node: jinja2.nodes.ExtensionAttribute, frame: Frame) -> None


   .. py:method:: visit_ImportedName(node: jinja2.nodes.ImportedName, frame: Frame) -> None


   .. py:method:: visit_InternalName(node: jinja2.nodes.InternalName, frame: Frame) -> None


   .. py:method:: visit_ContextReference(node: jinja2.nodes.ContextReference, frame: Frame) -> None


   .. py:method:: visit_DerivedContextReference(node: jinja2.nodes.DerivedContextReference, frame: Frame) -> None


   .. py:method:: visit_Continue(node: jinja2.nodes.Continue, frame: Frame) -> None


   .. py:method:: visit_Break(node: jinja2.nodes.Break, frame: Frame) -> None


   .. py:method:: visit_Scope(node: jinja2.nodes.Scope, frame: Frame) -> None


   .. py:method:: visit_OverlayScope(node: jinja2.nodes.OverlayScope, frame: Frame) -> None


   .. py:method:: visit_EvalContextModifier(node: jinja2.nodes.EvalContextModifier, frame: Frame) -> None


   .. py:method:: visit_ScopedEvalContextModifier(node: jinja2.nodes.ScopedEvalContextModifier, frame: Frame) -> None


