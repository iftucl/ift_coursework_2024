jinja2.visitor
==============

.. py:module:: jinja2.visitor

.. autoapi-nested-parse::

   API for traversing the AST nodes. Implemented by the compiler and
   meta introspection.



Classes
-------

.. autoapisummary::

   jinja2.visitor.VisitCallable
   jinja2.visitor.NodeVisitor
   jinja2.visitor.NodeTransformer


Module Contents
---------------

.. py:class:: VisitCallable

   Bases: :py:obj:`typing_extensions.Protocol`


   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing).

   For example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto[T](Protocol):
           def meth(self) -> T:
               ...


.. py:class:: NodeVisitor

   Walks the abstract syntax tree and call visitor functions for every
   node found.  The visitor functions may return values which will be
   forwarded by the `visit` method.

   Per default the visitor functions for the nodes are ``'visit_'`` +
   class name of the node.  So a `TryFinally` node visit function would
   be `visit_TryFinally`.  This behavior can be changed by overriding
   the `get_visitor` function.  If no visitor function exists for a node
   (return value `None`) the `generic_visit` visitor is used instead.


   .. py:method:: get_visitor(node: jinja2.nodes.Node) -> Optional[VisitCallable]

      Return the visitor function for this node or `None` if no visitor
      exists for this node.  In that case the generic visit function is
      used instead.



   .. py:method:: visit(node: jinja2.nodes.Node, *args: Any, **kwargs: Any) -> Any

      Visit a node.



   .. py:method:: generic_visit(node: jinja2.nodes.Node, *args: Any, **kwargs: Any) -> Any

      Called if no explicit visitor function exists for a node.



.. py:class:: NodeTransformer

   Bases: :py:obj:`NodeVisitor`


   Walks the abstract syntax tree and allows modifications of nodes.

   The `NodeTransformer` will walk the AST and use the return value of the
   visitor functions to replace or remove the old node.  If the return
   value of the visitor function is `None` the node will be removed
   from the previous location otherwise it's replaced with the return
   value.  The return value may be the original node in which case no
   replacement takes place.


   .. py:method:: generic_visit(node: jinja2.nodes.Node, *args: Any, **kwargs: Any) -> jinja2.nodes.Node

      Called if no explicit visitor function exists for a node.



   .. py:method:: visit_list(node: jinja2.nodes.Node, *args: Any, **kwargs: Any) -> List[jinja2.nodes.Node]

      As transformers may return lists in some places this method
      can be used to enforce a list as return value.



