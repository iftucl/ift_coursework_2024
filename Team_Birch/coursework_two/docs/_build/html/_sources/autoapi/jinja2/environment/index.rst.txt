jinja2.environment
==================

.. py:module:: jinja2.environment

.. autoapi-nested-parse::

   Classes for managing templates and their runtime and compile time
   options.



Classes
-------

.. autoapisummary::

   jinja2.environment.Environment
   jinja2.environment.Template
   jinja2.environment.TemplateModule
   jinja2.environment.TemplateExpression
   jinja2.environment.TemplateStream


Functions
---------

.. autoapisummary::

   jinja2.environment.get_spontaneous_environment
   jinja2.environment.create_cache
   jinja2.environment.copy_cache
   jinja2.environment.load_extensions


Module Contents
---------------

.. py:function:: get_spontaneous_environment(cls: Type[_env_bound], *args: Any) -> _env_bound

   Return a new spontaneous environment. A spontaneous environment
   is used for templates created directly rather than through an
   existing environment.

   :param cls: Environment class to create.
   :param args: Positional arguments passed to environment.


.. py:function:: create_cache(size: int) -> Optional[MutableMapping[Tuple[weakref.ref[t.Any], str], Template]]

   Return the cache class for the given size.


.. py:function:: copy_cache(cache: Optional[MutableMapping[Any, Any]]) -> Optional[MutableMapping[Tuple[weakref.ref[t.Any], str], Template]]

   Create an empty copy of the given cache.


.. py:function:: load_extensions(environment: Environment, extensions: Sequence[Union[str, Type[jinja2.ext.Extension]]]) -> Dict[str, jinja2.ext.Extension]

   Load the extensions from the list and bind it to the environment.
   Returns a dict of instantiated extensions.


.. py:class:: Environment(block_start_string: str = BLOCK_START_STRING, block_end_string: str = BLOCK_END_STRING, variable_start_string: str = VARIABLE_START_STRING, variable_end_string: str = VARIABLE_END_STRING, comment_start_string: str = COMMENT_START_STRING, comment_end_string: str = COMMENT_END_STRING, line_statement_prefix: Optional[str] = LINE_STATEMENT_PREFIX, line_comment_prefix: Optional[str] = LINE_COMMENT_PREFIX, trim_blocks: bool = TRIM_BLOCKS, lstrip_blocks: bool = LSTRIP_BLOCKS, newline_sequence: typing_extensions.Literal['\n', '\r\n', '\r'] = NEWLINE_SEQUENCE, keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE, extensions: Sequence[Union[str, Type[jinja2.ext.Extension]]] = (), optimized: bool = True, undefined: Type[jinja2.runtime.Undefined] = Undefined, finalize: Optional[Callable[Ellipsis, Any]] = None, autoescape: Union[bool, Callable[[Optional[str]], bool]] = False, loader: Optional[jinja2.loaders.BaseLoader] = None, cache_size: int = 400, auto_reload: bool = True, bytecode_cache: Optional[jinja2.bccache.BytecodeCache] = None, enable_async: bool = False)

   The core component of Jinja is the `Environment`.  It contains
   important shared variables like configuration, filters, tests,
   globals and others.  Instances of this class may be modified if
   they are not shared and if no template was loaded so far.
   Modifications on environments after the first template was loaded
   will lead to surprising effects and undefined behavior.

   Here are the possible initialization parameters:

       `block_start_string`
           The string marking the beginning of a block.  Defaults to ``'{%'``.

       `block_end_string`
           The string marking the end of a block.  Defaults to ``'%}'``.

       `variable_start_string`
           The string marking the beginning of a print statement.
           Defaults to ``'{{'``.

       `variable_end_string`
           The string marking the end of a print statement.  Defaults to
           ``'}}'``.

       `comment_start_string`
           The string marking the beginning of a comment.  Defaults to ``'{#'``.

       `comment_end_string`
           The string marking the end of a comment.  Defaults to ``'#}'``.

       `line_statement_prefix`
           If given and a string, this will be used as prefix for line based
           statements.  See also :ref:`line-statements`.

       `line_comment_prefix`
           If given and a string, this will be used as prefix for line based
           comments.  See also :ref:`line-statements`.

           .. versionadded:: 2.2

       `trim_blocks`
           If this is set to ``True`` the first newline after a block is
           removed (block, not variable tag!).  Defaults to `False`.

       `lstrip_blocks`
           If this is set to ``True`` leading spaces and tabs are stripped
           from the start of a line to a block.  Defaults to `False`.

       `newline_sequence`
           The sequence that starts a newline.  Must be one of ``'\r'``,
           ``'\n'`` or ``'\r\n'``.  The default is ``'\n'`` which is a
           useful default for Linux and OS X systems as well as web
           applications.

       `keep_trailing_newline`
           Preserve the trailing newline when rendering templates.
           The default is ``False``, which causes a single newline,
           if present, to be stripped from the end of the template.

           .. versionadded:: 2.7

       `extensions`
           List of Jinja extensions to use.  This can either be import paths
           as strings or extension classes.  For more information have a
           look at :ref:`the extensions documentation <jinja-extensions>`.

       `optimized`
           should the optimizer be enabled?  Default is ``True``.

       `undefined`
           :class:`Undefined` or a subclass of it that is used to represent
           undefined values in the template.

       `finalize`
           A callable that can be used to process the result of a variable
           expression before it is output.  For example one can convert
           ``None`` implicitly into an empty string here.

       `autoescape`
           If set to ``True`` the XML/HTML autoescaping feature is enabled by
           default.  For more details about autoescaping see
           :class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also
           be a callable that is passed the template name and has to
           return ``True`` or ``False`` depending on autoescape should be
           enabled by default.

           .. versionchanged:: 2.4
              `autoescape` can now be a function

       `loader`
           The template loader for this environment.

       `cache_size`
           The size of the cache.  Per default this is ``400`` which means
           that if more than 400 templates are loaded the loader will clean
           out the least recently used template.  If the cache size is set to
           ``0`` templates are recompiled all the time, if the cache size is
           ``-1`` the cache will not be cleaned.

           .. versionchanged:: 2.8
              The cache size was increased to 400 from a low 50.

       `auto_reload`
           Some loaders load templates from locations where the template
           sources may change (ie: file system or database).  If
           ``auto_reload`` is set to ``True`` (default) every time a template is
           requested the loader checks if the source changed and if yes, it
           will reload the template.  For higher performance it's possible to
           disable that.

       `bytecode_cache`
           If set to a bytecode cache object, this object will provide a
           cache for the internal Jinja bytecode so that templates don't
           have to be parsed if they were not changed.

           See :ref:`bytecode-cache` for more information.

       `enable_async`
           If set to true this enables async template execution which
           allows using async functions and generators.


   .. py:attribute:: sandboxed
      :value: False



   .. py:attribute:: overlayed
      :value: False



   .. py:attribute:: linked_to
      :type:  Optional[Environment]
      :value: None



   .. py:attribute:: shared
      :value: False



   .. py:attribute:: code_generator_class
      :type:  Type[jinja2.compiler.CodeGenerator]


   .. py:attribute:: concat


   .. py:attribute:: context_class
      :type:  Type[jinja2.runtime.Context]


   .. py:attribute:: template_class
      :type:  Type[Template]


   .. py:attribute:: block_start_string
      :value: '{%'



   .. py:attribute:: block_end_string
      :value: '%}'



   .. py:attribute:: variable_start_string
      :value: '{{'



   .. py:attribute:: variable_end_string
      :value: '}}'



   .. py:attribute:: comment_start_string
      :value: '{#'



   .. py:attribute:: comment_end_string
      :value: '#}'



   .. py:attribute:: line_statement_prefix
      :value: None



   .. py:attribute:: line_comment_prefix
      :value: None



   .. py:attribute:: trim_blocks
      :value: False



   .. py:attribute:: lstrip_blocks
      :value: False



   .. py:attribute:: newline_sequence
      :value: Multiline-String

      .. raw:: html

         <details><summary>Show Value</summary>

      .. code-block:: python

         """
         """

      .. raw:: html

         </details>




   .. py:attribute:: keep_trailing_newline
      :value: False



   .. py:attribute:: undefined
      :type:  Type[jinja2.runtime.Undefined]


   .. py:attribute:: optimized
      :value: True



   .. py:attribute:: finalize
      :value: None



   .. py:attribute:: autoescape
      :value: False



   .. py:attribute:: filters


   .. py:attribute:: tests


   .. py:attribute:: globals


   .. py:attribute:: loader
      :value: None



   .. py:attribute:: cache
      :value: None



   .. py:attribute:: bytecode_cache
      :value: None



   .. py:attribute:: auto_reload
      :value: True



   .. py:attribute:: policies


   .. py:attribute:: extensions


   .. py:attribute:: is_async
      :value: False



   .. py:method:: add_extension(extension: Union[str, Type[jinja2.ext.Extension]]) -> None

      Adds an extension after the environment was created.

      .. versionadded:: 2.5



   .. py:method:: extend(**attributes: Any) -> None

      Add the items to the instance of the environment if they do not exist
      yet.  This is used by :ref:`extensions <writing-extensions>` to register
      callbacks and configuration values without breaking inheritance.



   .. py:method:: overlay(block_start_string: str = missing, block_end_string: str = missing, variable_start_string: str = missing, variable_end_string: str = missing, comment_start_string: str = missing, comment_end_string: str = missing, line_statement_prefix: Optional[str] = missing, line_comment_prefix: Optional[str] = missing, trim_blocks: bool = missing, lstrip_blocks: bool = missing, newline_sequence: typing_extensions.Literal['\n', '\r\n', '\r'] = missing, keep_trailing_newline: bool = missing, extensions: Sequence[Union[str, Type[jinja2.ext.Extension]]] = missing, optimized: bool = missing, undefined: Type[jinja2.runtime.Undefined] = missing, finalize: Optional[Callable[Ellipsis, Any]] = missing, autoescape: Union[bool, Callable[[Optional[str]], bool]] = missing, loader: Optional[jinja2.loaders.BaseLoader] = missing, cache_size: int = missing, auto_reload: bool = missing, bytecode_cache: Optional[jinja2.bccache.BytecodeCache] = missing, enable_async: bool = missing) -> typing_extensions.Self

      Create a new overlay environment that shares all the data with the
      current environment except for cache and the overridden attributes.
      Extensions cannot be removed for an overlayed environment.  An overlayed
      environment automatically gets all the extensions of the environment it
      is linked to plus optional extra extensions.

      Creating overlays should happen after the initial environment was set
      up completely.  Not all attributes are truly linked, some are just
      copied over so modifications on the original environment may not shine
      through.

      .. versionchanged:: 3.1.5
          ``enable_async`` is applied correctly.

      .. versionchanged:: 3.1.2
          Added the ``newline_sequence``, ``keep_trailing_newline``,
          and ``enable_async`` parameters to match ``__init__``.



   .. py:property:: lexer
      :type: jinja2.lexer.Lexer


      The lexer for this environment.


   .. py:method:: iter_extensions() -> Iterator[jinja2.ext.Extension]

      Iterates over the extensions by priority.



   .. py:method:: getitem(obj: Any, argument: Union[str, Any]) -> Union[Any, jinja2.runtime.Undefined]

      Get an item or attribute of an object but prefer the item.



   .. py:method:: getattr(obj: Any, attribute: str) -> Any

      Get an item or attribute of an object but prefer the attribute.
      Unlike :meth:`getitem` the attribute *must* be a string.



   .. py:method:: call_filter(name: str, value: Any, args: Optional[Sequence[Any]] = None, kwargs: Optional[Mapping[str, Any]] = None, context: Optional[jinja2.runtime.Context] = None, eval_ctx: Optional[jinja2.nodes.EvalContext] = None) -> Any

      Invoke a filter on a value the same way the compiler does.

      This might return a coroutine if the filter is running from an
      environment in async mode and the filter supports async
      execution. It's your responsibility to await this if needed.

      .. versionadded:: 2.7



   .. py:method:: call_test(name: str, value: Any, args: Optional[Sequence[Any]] = None, kwargs: Optional[Mapping[str, Any]] = None, context: Optional[jinja2.runtime.Context] = None, eval_ctx: Optional[jinja2.nodes.EvalContext] = None) -> Any

      Invoke a test on a value the same way the compiler does.

      This might return a coroutine if the test is running from an
      environment in async mode and the test supports async execution.
      It's your responsibility to await this if needed.

      .. versionchanged:: 3.0
          Tests support ``@pass_context``, etc. decorators. Added
          the ``context`` and ``eval_ctx`` parameters.

      .. versionadded:: 2.7



   .. py:method:: parse(source: str, name: Optional[str] = None, filename: Optional[str] = None) -> jinja2.nodes.Template

      Parse the sourcecode and return the abstract syntax tree.  This
      tree of nodes is used by the compiler to convert the template into
      executable source- or bytecode.  This is useful for debugging or to
      extract information from templates.

      If you are :ref:`developing Jinja extensions <writing-extensions>`
      this gives you a good overview of the node tree generated.



   .. py:method:: lex(source: str, name: Optional[str] = None, filename: Optional[str] = None) -> Iterator[Tuple[int, str, str]]

      Lex the given sourcecode and return a generator that yields
      tokens as tuples in the form ``(lineno, token_type, value)``.
      This can be useful for :ref:`extension development <writing-extensions>`
      and debugging templates.

      This does not perform preprocessing.  If you want the preprocessing
      of the extensions to be applied you have to filter source through
      the :meth:`preprocess` method.



   .. py:method:: preprocess(source: str, name: Optional[str] = None, filename: Optional[str] = None) -> str

      Preprocesses the source with all extensions.  This is automatically
      called for all parsing and compiling methods but *not* for :meth:`lex`
      because there you usually only want the actual source tokenized.



   .. py:method:: compile(source: Union[str, jinja2.nodes.Template], name: Optional[str] = None, filename: Optional[str] = None, raw: typing_extensions.Literal[False] = False, defer_init: bool = False) -> types.CodeType
                  compile(source: Union[str, jinja2.nodes.Template], name: Optional[str] = None, filename: Optional[str] = None, raw: typing_extensions.Literal[True] = ..., defer_init: bool = False) -> str

      Compile a node or template source code.  The `name` parameter is
      the load name of the template after it was joined using
      :meth:`join_path` if necessary, not the filename on the file system.
      the `filename` parameter is the estimated filename of the template on
      the file system.  If the template came from a database or memory this
      can be omitted.

      The return value of this method is a python code object.  If the `raw`
      parameter is `True` the return value will be a string with python
      code equivalent to the bytecode returned otherwise.  This method is
      mainly used internally.

      `defer_init` is use internally to aid the module code generator.  This
      causes the generated code to be able to import without the global
      environment variable to be set.

      .. versionadded:: 2.4
         `defer_init` parameter added.



   .. py:method:: compile_expression(source: str, undefined_to_none: bool = True) -> TemplateExpression

      A handy helper method that returns a callable that accepts keyword
      arguments that appear as variables in the expression.  If called it
      returns the result of the expression.

      This is useful if applications want to use the same rules as Jinja
      in template "configuration files" or similar situations.

      Example usage:

      >>> env = Environment()
      >>> expr = env.compile_expression('foo == 42')
      >>> expr(foo=23)
      False
      >>> expr(foo=42)
      True

      Per default the return value is converted to `None` if the
      expression returns an undefined value.  This can be changed
      by setting `undefined_to_none` to `False`.

      >>> env.compile_expression('var')() is None
      True
      >>> env.compile_expression('var', undefined_to_none=False)()
      Undefined

      .. versionadded:: 2.1



   .. py:method:: compile_templates(target: Union[str, os.PathLike[str]], extensions: Optional[Collection[str]] = None, filter_func: Optional[Callable[[str], bool]] = None, zip: Optional[str] = 'deflated', log_function: Optional[Callable[[str], None]] = None, ignore_errors: bool = True) -> None

      Finds all the templates the loader can find, compiles them
      and stores them in `target`.  If `zip` is `None`, instead of in a
      zipfile, the templates will be stored in a directory.
      By default a deflate zip algorithm is used. To switch to
      the stored algorithm, `zip` can be set to ``'stored'``.

      `extensions` and `filter_func` are passed to :meth:`list_templates`.
      Each template returned will be compiled to the target folder or
      zipfile.

      By default template compilation errors are ignored.  In case a
      log function is provided, errors are logged.  If you want template
      syntax errors to abort the compilation you can set `ignore_errors`
      to `False` and you will get an exception on syntax errors.

      .. versionadded:: 2.4



   .. py:method:: list_templates(extensions: Optional[Collection[str]] = None, filter_func: Optional[Callable[[str], bool]] = None) -> List[str]

      Returns a list of templates for this environment.  This requires
      that the loader supports the loader's
      :meth:`~BaseLoader.list_templates` method.

      If there are other files in the template folder besides the
      actual templates, the returned list can be filtered.  There are two
      ways: either `extensions` is set to a list of file extensions for
      templates, or a `filter_func` can be provided which is a callable that
      is passed a template name and should return `True` if it should end up
      in the result list.

      If the loader does not support that, a :exc:`TypeError` is raised.

      .. versionadded:: 2.4



   .. py:method:: handle_exception(source: Optional[str] = None) -> typing_extensions.NoReturn

      Exception handling helper.  This is used internally to either raise
      rewritten exceptions or return a rendered traceback for the template.



   .. py:method:: join_path(template: str, parent: str) -> str

      Join a template with the parent.  By default all the lookups are
      relative to the loader root so this method returns the `template`
      parameter unchanged, but if the paths should be relative to the
      parent template, this function can be used to calculate the real
      template name.

      Subclasses may override this method and implement template path
      joining here.



   .. py:method:: get_template(name: Union[str, Template], parent: Optional[str] = None, globals: Optional[MutableMapping[str, Any]] = None) -> Template

      Load a template by name with :attr:`loader` and return a
      :class:`Template`. If the template does not exist a
      :exc:`TemplateNotFound` exception is raised.

      :param name: Name of the template to load. When loading
          templates from the filesystem, "/" is used as the path
          separator, even on Windows.
      :param parent: The name of the parent template importing this
          template. :meth:`join_path` can be used to implement name
          transformations with this.
      :param globals: Extend the environment :attr:`globals` with
          these extra variables available for all renders of this
          template. If the template has already been loaded and
          cached, its globals are updated with any new items.

      .. versionchanged:: 3.0
          If a template is loaded from cache, ``globals`` will update
          the template's globals instead of ignoring the new values.

      .. versionchanged:: 2.4
          If ``name`` is a :class:`Template` object it is returned
          unchanged.



   .. py:method:: select_template(names: Iterable[Union[str, Template]], parent: Optional[str] = None, globals: Optional[MutableMapping[str, Any]] = None) -> Template

      Like :meth:`get_template`, but tries loading multiple names.
      If none of the names can be loaded a :exc:`TemplatesNotFound`
      exception is raised.

      :param names: List of template names to try loading in order.
      :param parent: The name of the parent template importing this
          template. :meth:`join_path` can be used to implement name
          transformations with this.
      :param globals: Extend the environment :attr:`globals` with
          these extra variables available for all renders of this
          template. If the template has already been loaded and
          cached, its globals are updated with any new items.

      .. versionchanged:: 3.0
          If a template is loaded from cache, ``globals`` will update
          the template's globals instead of ignoring the new values.

      .. versionchanged:: 2.11
          If ``names`` is :class:`Undefined`, an :exc:`UndefinedError`
          is raised instead. If no templates were found and ``names``
          contains :class:`Undefined`, the message is more helpful.

      .. versionchanged:: 2.4
          If ``names`` contains a :class:`Template` object it is
          returned unchanged.

      .. versionadded:: 2.3



   .. py:method:: get_or_select_template(template_name_or_list: Union[str, Template, List[Union[str, Template]]], parent: Optional[str] = None, globals: Optional[MutableMapping[str, Any]] = None) -> Template

      Use :meth:`select_template` if an iterable of template names
      is given, or :meth:`get_template` if one name is given.

      .. versionadded:: 2.3



   .. py:method:: from_string(source: Union[str, jinja2.nodes.Template], globals: Optional[MutableMapping[str, Any]] = None, template_class: Optional[Type[Template]] = None) -> Template

      Load a template from a source string without using
      :attr:`loader`.

      :param source: Jinja source to compile into a template.
      :param globals: Extend the environment :attr:`globals` with
          these extra variables available for all renders of this
          template. If the template has already been loaded and
          cached, its globals are updated with any new items.
      :param template_class: Return an instance of this
          :class:`Template` class.



   .. py:method:: make_globals(d: Optional[MutableMapping[str, Any]]) -> MutableMapping[str, Any]

      Make the globals map for a template. Any given template
      globals overlay the environment :attr:`globals`.

      Returns a :class:`collections.ChainMap`. This allows any changes
      to a template's globals to only affect that template, while
      changes to the environment's globals are still reflected.
      However, avoid modifying any globals after a template is loaded.

      :param d: Dict of template-specific globals.

      .. versionchanged:: 3.0
          Use :class:`collections.ChainMap` to always prevent mutating
          environment globals.



.. py:class:: Template

   A compiled template that can be rendered.

   Use the methods on :class:`Environment` to create or load templates.
   The environment is used to configure how templates are compiled and
   behave.

   It is also possible to create a template object directly. This is
   not usually recommended. The constructor takes most of the same
   arguments as :class:`Environment`. All templates created with the
   same environment arguments share the same ephemeral ``Environment``
   instance behind the scenes.

   A template object should be considered immutable. Modifications on
   the object are not supported.


   .. py:attribute:: environment_class
      :type:  Type[Environment]


   .. py:attribute:: environment
      :type:  Environment


   .. py:attribute:: globals
      :type:  MutableMapping[str, Any]


   .. py:attribute:: name
      :type:  Optional[str]


   .. py:attribute:: filename
      :type:  Optional[str]


   .. py:attribute:: blocks
      :type:  Dict[str, Callable[[jinja2.runtime.Context], Iterator[str]]]


   .. py:attribute:: root_render_func
      :type:  Callable[[jinja2.runtime.Context], Iterator[str]]


   .. py:method:: from_code(environment: Environment, code: types.CodeType, globals: MutableMapping[str, Any], uptodate: Optional[Callable[[], bool]] = None) -> Template
      :classmethod:


      Creates a template object from compiled code and the globals.  This
      is used by the loaders and environment to create a template object.



   .. py:method:: from_module_dict(environment: Environment, module_dict: MutableMapping[str, Any], globals: MutableMapping[str, Any]) -> Template
      :classmethod:


      Creates a template object from a module.  This is used by the
      module loader to create a template object.

      .. versionadded:: 2.4



   .. py:method:: render(*args: Any, **kwargs: Any) -> str

      This method accepts the same arguments as the `dict` constructor:
      A dict, a dict subclass or some keyword arguments.  If no arguments
      are given the context will be empty.  These two calls do the same::

          template.render(knights='that say nih')
          template.render({'knights': 'that say nih'})

      This will return the rendered template as a string.



   .. py:method:: render_async(*args: Any, **kwargs: Any) -> str
      :async:


      This works similar to :meth:`render` but returns a coroutine
      that when awaited returns the entire rendered template string.  This
      requires the async feature to be enabled.

      Example usage::

          await template.render_async(knights='that say nih; asynchronously')



   .. py:method:: stream(*args: Any, **kwargs: Any) -> TemplateStream

      Works exactly like :meth:`generate` but returns a
      :class:`TemplateStream`.



   .. py:method:: generate(*args: Any, **kwargs: Any) -> Iterator[str]

      For very large templates it can be useful to not render the whole
      template at once but evaluate each statement after another and yield
      piece for piece.  This method basically does exactly that and returns
      a generator that yields one item after another as strings.

      It accepts the same arguments as :meth:`render`.



   .. py:method:: generate_async(*args: Any, **kwargs: Any) -> AsyncGenerator[str, object]
      :async:


      An async version of :meth:`generate`.  Works very similarly but
      returns an async iterator instead.



   .. py:method:: new_context(vars: Optional[Dict[str, Any]] = None, shared: bool = False, locals: Optional[Mapping[str, Any]] = None) -> jinja2.runtime.Context

      Create a new :class:`Context` for this template.  The vars
      provided will be passed to the template.  Per default the globals
      are added to the context.  If shared is set to `True` the data
      is passed as is to the context without adding the globals.

      `locals` can be a dict of local variables for internal usage.



   .. py:method:: make_module(vars: Optional[Dict[str, Any]] = None, shared: bool = False, locals: Optional[Mapping[str, Any]] = None) -> TemplateModule

      This method works like the :attr:`module` attribute when called
      without arguments but it will evaluate the template on every call
      rather than caching it.  It's also possible to provide
      a dict which is then used as context.  The arguments are the same
      as for the :meth:`new_context` method.



   .. py:method:: make_module_async(vars: Optional[Dict[str, Any]] = None, shared: bool = False, locals: Optional[Mapping[str, Any]] = None) -> TemplateModule
      :async:


      As template module creation can invoke template code for
      asynchronous executions this method must be used instead of the
      normal :meth:`make_module` one.  Likewise the module attribute
      becomes unavailable in async mode.



   .. py:property:: module
      :type: TemplateModule


      The template as module.  This is used for imports in the
      template runtime but is also useful if one wants to access
      exported template variables from the Python layer:

      >>> t = Template('{% macro foo() %}42{% endmacro %}23')
      >>> str(t.module)
      '23'
      >>> t.module.foo() == u'42'
      True

      This attribute is not available if async mode is enabled.


   .. py:method:: get_corresponding_lineno(lineno: int) -> int

      Return the source line number of a line number in the
      generated bytecode as they are not in sync.



   .. py:property:: is_up_to_date
      :type: bool


      If this variable is `False` there is a newer version available.


   .. py:property:: debug_info
      :type: List[Tuple[int, int]]


      The debug info mapping.


.. py:class:: TemplateModule(template: Template, context: jinja2.runtime.Context, body_stream: Optional[Iterable[str]] = None)

   Represents an imported template.  All the exported names of the
   template are available as attributes on this object.  Additionally
   converting it into a string renders the contents.


.. py:class:: TemplateExpression(template: Template, undefined_to_none: bool)

   The :meth:`jinja2.Environment.compile_expression` method returns an
   instance of this object.  It encapsulates the expression-like access
   to the template with an expression it wraps.


.. py:class:: TemplateStream(gen: Iterator[str])

   A template stream works pretty much like an ordinary python generator
   but it can buffer multiple items to reduce the number of total iterations.
   Per default the output is unbuffered which means that for every unbuffered
   instruction in the template one string is yielded.

   If buffering is enabled with a buffer size of 5, five items are combined
   into a new string.  This is mainly useful if you are streaming
   big templates to a client via WSGI which flushes after each iteration.


   .. py:method:: dump(fp: Union[str, IO[bytes]], encoding: Optional[str] = None, errors: Optional[str] = 'strict') -> None

      Dump the complete stream into a file or file-like object.
      Per default strings are written, if you want to encode
      before writing specify an `encoding`.

      Example usage::

          Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')



   .. py:method:: disable_buffering() -> None

      Disable the output buffering.



   .. py:method:: enable_buffering(size: int = 5) -> None

      Enable buffering.  Buffer `size` items before yielding them.



