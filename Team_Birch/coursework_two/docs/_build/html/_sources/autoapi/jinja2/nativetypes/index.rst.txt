jinja2.nativetypes
==================

.. py:module:: jinja2.nativetypes


Classes
-------

.. autoapisummary::

   jinja2.nativetypes.NativeCodeGenerator
   jinja2.nativetypes.NativeEnvironment
   jinja2.nativetypes.NativeTemplate


Functions
---------

.. autoapisummary::

   jinja2.nativetypes.native_concat


Module Contents
---------------

.. py:function:: native_concat(values: Iterable[Any]) -> Optional[Any]

   Return a native Python type from the list of compiled nodes. If
   the result is a single node, its value is returned. Otherwise, the
   nodes are concatenated as strings. If the result can be parsed with
   :func:`ast.literal_eval`, the parsed value is returned. Otherwise,
   the string is returned.

   :param values: Iterable of outputs to concatenate.


.. py:class:: NativeCodeGenerator(environment: jinja2.environment.Environment, name: Optional[str], filename: Optional[str], stream: Optional[TextIO] = None, defer_init: bool = False, optimized: bool = True)

   Bases: :py:obj:`jinja2.compiler.CodeGenerator`


   A code generator which renders Python types by not adding
   ``str()`` around output nodes.


.. py:class:: NativeEnvironment(block_start_string: str = BLOCK_START_STRING, block_end_string: str = BLOCK_END_STRING, variable_start_string: str = VARIABLE_START_STRING, variable_end_string: str = VARIABLE_END_STRING, comment_start_string: str = COMMENT_START_STRING, comment_end_string: str = COMMENT_END_STRING, line_statement_prefix: Optional[str] = LINE_STATEMENT_PREFIX, line_comment_prefix: Optional[str] = LINE_COMMENT_PREFIX, trim_blocks: bool = TRIM_BLOCKS, lstrip_blocks: bool = LSTRIP_BLOCKS, newline_sequence: typing_extensions.Literal['\n', '\r\n', '\r'] = NEWLINE_SEQUENCE, keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE, extensions: Sequence[Union[str, Type[jinja2.ext.Extension]]] = (), optimized: bool = True, undefined: Type[jinja2.runtime.Undefined] = Undefined, finalize: Optional[Callable[Ellipsis, Any]] = None, autoescape: Union[bool, Callable[[Optional[str]], bool]] = False, loader: Optional[jinja2.loaders.BaseLoader] = None, cache_size: int = 400, auto_reload: bool = True, bytecode_cache: Optional[jinja2.bccache.BytecodeCache] = None, enable_async: bool = False)

   Bases: :py:obj:`jinja2.environment.Environment`


   An environment that renders templates to native Python types.


   .. py:attribute:: code_generator_class


   .. py:attribute:: concat


.. py:class:: NativeTemplate

   Bases: :py:obj:`jinja2.environment.Template`


   A compiled template that can be rendered.

   Use the methods on :class:`Environment` to create or load templates.
   The environment is used to configure how templates are compiled and
   behave.

   It is also possible to create a template object directly. This is
   not usually recommended. The constructor takes most of the same
   arguments as :class:`Environment`. All templates created with the
   same environment arguments share the same ephemeral ``Environment``
   instance behind the scenes.

   A template object should be considered immutable. Modifications on
   the object are not supported.


   .. py:attribute:: environment_class


   .. py:method:: render(*args: Any, **kwargs: Any) -> Any

      Render the template to produce a native Python type. If the
      result is a single node, its value is returned. Otherwise, the
      nodes are concatenated as strings. If the result can be parsed
      with :func:`ast.literal_eval`, the parsed value is returned.
      Otherwise, the string is returned.



   .. py:method:: render_async(*args: Any, **kwargs: Any) -> Any
      :async:


      This works similar to :meth:`render` but returns a coroutine
      that when awaited returns the entire rendered template string.  This
      requires the async feature to be enabled.

      Example usage::

          await template.render_async(knights='that say nih; asynchronously')



