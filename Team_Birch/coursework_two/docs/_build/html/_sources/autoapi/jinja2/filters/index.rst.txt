jinja2.filters
==============

.. py:module:: jinja2.filters

.. autoapi-nested-parse::

   Built-in template filters used with the ``|`` operator.



Attributes
----------

.. autoapisummary::

   jinja2.filters.F
   jinja2.filters.K
   jinja2.filters.V
   jinja2.filters.FILTERS


Classes
-------

.. autoapisummary::

   jinja2.filters.HasHTML


Functions
---------

.. autoapisummary::

   jinja2.filters.ignore_case
   jinja2.filters.make_attrgetter
   jinja2.filters.make_multi_attrgetter
   jinja2.filters.do_forceescape
   jinja2.filters.do_urlencode
   jinja2.filters.do_replace
   jinja2.filters.do_upper
   jinja2.filters.do_lower
   jinja2.filters.do_items
   jinja2.filters.do_xmlattr
   jinja2.filters.do_capitalize
   jinja2.filters.do_title
   jinja2.filters.do_dictsort
   jinja2.filters.do_sort
   jinja2.filters.sync_do_unique
   jinja2.filters.do_unique
   jinja2.filters.do_min
   jinja2.filters.do_max
   jinja2.filters.do_default
   jinja2.filters.sync_do_join
   jinja2.filters.do_join
   jinja2.filters.do_center
   jinja2.filters.sync_do_first
   jinja2.filters.do_first
   jinja2.filters.do_last
   jinja2.filters.do_random
   jinja2.filters.do_filesizeformat
   jinja2.filters.do_pprint
   jinja2.filters.do_urlize
   jinja2.filters.do_indent
   jinja2.filters.do_truncate
   jinja2.filters.do_wordwrap
   jinja2.filters.do_wordcount
   jinja2.filters.do_int
   jinja2.filters.do_float
   jinja2.filters.do_format
   jinja2.filters.do_trim
   jinja2.filters.do_striptags
   jinja2.filters.sync_do_slice
   jinja2.filters.do_slice
   jinja2.filters.do_batch
   jinja2.filters.do_round
   jinja2.filters.sync_do_groupby
   jinja2.filters.do_groupby
   jinja2.filters.sync_do_sum
   jinja2.filters.do_sum
   jinja2.filters.sync_do_list
   jinja2.filters.do_list
   jinja2.filters.do_mark_safe
   jinja2.filters.do_mark_unsafe
   jinja2.filters.do_reverse
   jinja2.filters.do_attr
   jinja2.filters.sync_do_map
   jinja2.filters.do_map
   jinja2.filters.sync_do_select
   jinja2.filters.do_select
   jinja2.filters.sync_do_reject
   jinja2.filters.do_reject
   jinja2.filters.sync_do_selectattr
   jinja2.filters.do_selectattr
   jinja2.filters.sync_do_rejectattr
   jinja2.filters.do_rejectattr
   jinja2.filters.do_tojson
   jinja2.filters.prepare_map
   jinja2.filters.prepare_select_or_reject
   jinja2.filters.select_or_reject
   jinja2.filters.async_select_or_reject


Module Contents
---------------

.. py:class:: HasHTML

   Bases: :py:obj:`typing_extensions.Protocol`


   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing).

   For example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto[T](Protocol):
           def meth(self) -> T:
               ...


.. py:data:: F

.. py:data:: K

.. py:data:: V

.. py:function:: ignore_case(value: V) -> V

   For use as a postprocessor for :func:`make_attrgetter`. Converts strings
   to lowercase and returns other types as-is.


.. py:function:: make_attrgetter(environment: jinja2.environment.Environment, attribute: Optional[Union[str, int]], postprocess: Optional[Callable[[Any], Any]] = None, default: Optional[Any] = None) -> Callable[[Any], Any]

   Returns a callable that looks up the given attribute from a
   passed object with the rules of the environment.  Dots are allowed
   to access attributes of attributes.  Integer parts in paths are
   looked up as integers.


.. py:function:: make_multi_attrgetter(environment: jinja2.environment.Environment, attribute: Optional[Union[str, int]], postprocess: Optional[Callable[[Any], Any]] = None) -> Callable[[Any], List[Any]]

   Returns a callable that looks up the given comma separated
   attributes from a passed object with the rules of the environment.
   Dots are allowed to access attributes of each attribute.  Integer
   parts in paths are looked up as integers.

   The value returned by the returned callable is a list of extracted
   attribute values.

   Examples of attribute: "attr1,attr2", "attr1.inner1.0,attr2.inner2.0", etc.


.. py:function:: do_forceescape(value: Union[str, HasHTML]) -> markupsafe.Markup

   Enforce HTML escaping.  This will probably double escape variables.


.. py:function:: do_urlencode(value: Union[str, Mapping[str, Any], Iterable[Tuple[str, Any]]]) -> str

   Quote data for use in a URL path or query using UTF-8.

   Basic wrapper around :func:`urllib.parse.quote` when given a
   string, or :func:`urllib.parse.urlencode` for a dict or iterable.

   :param value: Data to quote. A string will be quoted directly. A
       dict or iterable of ``(key, value)`` pairs will be joined as a
       query string.

   When given a string, "/" is not quoted. HTTP servers treat "/" and
   "%2F" equivalently in paths. If you need quoted slashes, use the
   ``|replace("/", "%2F")`` filter.

   .. versionadded:: 2.7


.. py:function:: do_replace(eval_ctx: jinja2.nodes.EvalContext, s: str, old: str, new: str, count: Optional[int] = None) -> str

   Return a copy of the value with all occurrences of a substring
   replaced with a new one. The first argument is the substring
   that should be replaced, the second is the replacement string.
   If the optional third argument ``count`` is given, only the first
   ``count`` occurrences are replaced:

   .. sourcecode:: jinja

       {{ "Hello World"|replace("Hello", "Goodbye") }}
           -> Goodbye World

       {{ "aaaaargh"|replace("a", "d'oh, ", 2) }}
           -> d'oh, d'oh, aaargh


.. py:function:: do_upper(s: str) -> str

   Convert a value to uppercase.


.. py:function:: do_lower(s: str) -> str

   Convert a value to lowercase.


.. py:function:: do_items(value: Union[Mapping[K, V], jinja2.runtime.Undefined]) -> Iterator[Tuple[K, V]]

   Return an iterator over the ``(key, value)`` items of a mapping.

   ``x|items`` is the same as ``x.items()``, except if ``x`` is
   undefined an empty iterator is returned.

   This filter is useful if you expect the template to be rendered with
   an implementation of Jinja in another programming language that does
   not have a ``.items()`` method on its mapping type.

   .. code-block:: html+jinja

       <dl>
       {% for key, value in my_dict|items %}
           <dt>{{ key }}
           <dd>{{ value }}
       {% endfor %}
       </dl>

   .. versionadded:: 3.1


.. py:function:: do_xmlattr(eval_ctx: jinja2.nodes.EvalContext, d: Mapping[str, Any], autospace: bool = True) -> str

   Create an SGML/XML attribute string based on the items in a dict.

   **Values** that are neither ``none`` nor ``undefined`` are automatically
   escaped, safely allowing untrusted user input.

   User input should not be used as **keys** to this filter. If any key
   contains a space, ``/`` solidus, ``>`` greater-than sign, or ``=`` equals
   sign, this fails with a ``ValueError``. Regardless of this, user input
   should never be used as keys to this filter, or must be separately validated
   first.

   .. sourcecode:: html+jinja

       <ul{{ {'class': 'my_list', 'missing': none,
               'id': 'list-%d'|format(variable)}|xmlattr }}>
       ...
       </ul>

   Results in something like this:

   .. sourcecode:: html

       <ul class="my_list" id="list-42">
       ...
       </ul>

   As you can see it automatically prepends a space in front of the item
   if the filter returned something unless the second parameter is false.

   .. versionchanged:: 3.1.4
       Keys with ``/`` solidus, ``>`` greater-than sign, or ``=`` equals sign
       are not allowed.

   .. versionchanged:: 3.1.3
       Keys with spaces are not allowed.


.. py:function:: do_capitalize(s: str) -> str

   Capitalize a value. The first character will be uppercase, all others
   lowercase.


.. py:function:: do_title(s: str) -> str

   Return a titlecased version of the value. I.e. words will start with
   uppercase letters, all remaining characters are lowercase.


.. py:function:: do_dictsort(value: Mapping[K, V], case_sensitive: bool = False, by: typing_extensions.Literal["key", "value"] = 'key', reverse: bool = False) -> List[Tuple[K, V]]

   Sort a dict and yield (key, value) pairs. Python dicts may not
   be in the order you want to display them in, so sort them first.

   .. sourcecode:: jinja

       {% for key, value in mydict|dictsort %}
           sort the dict by key, case insensitive

       {% for key, value in mydict|dictsort(reverse=true) %}
           sort the dict by key, case insensitive, reverse order

       {% for key, value in mydict|dictsort(true) %}
           sort the dict by key, case sensitive

       {% for key, value in mydict|dictsort(false, 'value') %}
           sort the dict by value, case insensitive


.. py:function:: do_sort(environment: jinja2.environment.Environment, value: Iterable[V], reverse: bool = False, case_sensitive: bool = False, attribute: Optional[Union[str, int]] = None) -> List[V]

   Sort an iterable using Python's :func:`sorted`.

   .. sourcecode:: jinja

       {% for city in cities|sort %}
           ...
       {% endfor %}

   :param reverse: Sort descending instead of ascending.
   :param case_sensitive: When sorting strings, sort upper and lower
       case separately.
   :param attribute: When sorting objects or dicts, an attribute or
       key to sort by. Can use dot notation like ``"address.city"``.
       Can be a list of attributes like ``"age,name"``.

   The sort is stable, it does not change the relative order of
   elements that compare equal. This makes it is possible to chain
   sorts on different attributes and ordering.

   .. sourcecode:: jinja

       {% for user in users|sort(attribute="name")
           |sort(reverse=true, attribute="age") %}
           ...
       {% endfor %}

   As a shortcut to chaining when the direction is the same for all
   attributes, pass a comma separate list of attributes.

   .. sourcecode:: jinja

       {% for user in users|sort(attribute="age,name") %}
           ...
       {% endfor %}

   .. versionchanged:: 2.11.0
       The ``attribute`` parameter can be a comma separated list of
       attributes, e.g. ``"age,name"``.

   .. versionchanged:: 2.6
      The ``attribute`` parameter was added.


.. py:function:: sync_do_unique(environment: jinja2.environment.Environment, value: Iterable[V], case_sensitive: bool = False, attribute: Optional[Union[str, int]] = None) -> Iterator[V]

   Returns a list of unique items from the given iterable.

   .. sourcecode:: jinja

       {{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}
           -> ['foo', 'bar', 'foobar']

   The unique items are yielded in the same order as their first occurrence in
   the iterable passed to the filter.

   :param case_sensitive: Treat upper and lower case strings as distinct.
   :param attribute: Filter objects with unique values for this attribute.


.. py:function:: do_unique(environment: jinja2.environment.Environment, value: Union[t.AsyncIterable[V], t.Iterable[V]], case_sensitive: bool = False, attribute: Optional[Union[str, int]] = None) -> Iterator[V]
   :async:


.. py:function:: do_min(environment: jinja2.environment.Environment, value: Iterable[V], case_sensitive: bool = False, attribute: Optional[Union[str, int]] = None) -> Union[V, Undefined]

   Return the smallest item from the sequence.

   .. sourcecode:: jinja

       {{ [1, 2, 3]|min }}
           -> 1

   :param case_sensitive: Treat upper and lower case strings as distinct.
   :param attribute: Get the object with the min value of this attribute.


.. py:function:: do_max(environment: jinja2.environment.Environment, value: Iterable[V], case_sensitive: bool = False, attribute: Optional[Union[str, int]] = None) -> Union[V, Undefined]

   Return the largest item from the sequence.

   .. sourcecode:: jinja

       {{ [1, 2, 3]|max }}
           -> 3

   :param case_sensitive: Treat upper and lower case strings as distinct.
   :param attribute: Get the object with the max value of this attribute.


.. py:function:: do_default(value: V, default_value: V = '', boolean: bool = False) -> V

   If the value is undefined it will return the passed default value,
   otherwise the value of the variable:

   .. sourcecode:: jinja

       {{ my_variable|default('my_variable is not defined') }}

   This will output the value of ``my_variable`` if the variable was
   defined, otherwise ``'my_variable is not defined'``. If you want
   to use default with variables that evaluate to false you have to
   set the second parameter to `true`:

   .. sourcecode:: jinja

       {{ ''|default('the string was empty', true) }}

   .. versionchanged:: 2.11
      It's now possible to configure the :class:`~jinja2.Environment` with
      :class:`~jinja2.ChainableUndefined` to make the `default` filter work
      on nested elements and attributes that may contain undefined values
      in the chain without getting an :exc:`~jinja2.UndefinedError`.


.. py:function:: sync_do_join(eval_ctx: jinja2.nodes.EvalContext, value: Iterable[Any], d: str = '', attribute: Optional[Union[str, int]] = None) -> str

   Return a string which is the concatenation of the strings in the
   sequence. The separator between elements is an empty string per
   default, you can define it with the optional parameter:

   .. sourcecode:: jinja

       {{ [1, 2, 3]|join('|') }}
           -> 1|2|3

       {{ [1, 2, 3]|join }}
           -> 123

   It is also possible to join certain attributes of an object:

   .. sourcecode:: jinja

       {{ users|join(', ', attribute='username') }}

   .. versionadded:: 2.6
      The `attribute` parameter was added.


.. py:function:: do_join(eval_ctx: jinja2.nodes.EvalContext, value: Union[AsyncIterable[Any], Iterable[Any]], d: str = '', attribute: Optional[Union[str, int]] = None) -> str
   :async:


.. py:function:: do_center(value: str, width: int = 80) -> str

   Centers the value in a field of a given width.


.. py:function:: sync_do_first(environment: jinja2.environment.Environment, seq: Iterable[V]) -> Union[V, Undefined]

   Return the first item of a sequence.


.. py:function:: do_first(environment: jinja2.environment.Environment, seq: Union[t.AsyncIterable[V], t.Iterable[V]]) -> Union[V, Undefined]
   :async:


.. py:function:: do_last(environment: jinja2.environment.Environment, seq: Reversible[V]) -> Union[V, Undefined]

   Return the last item of a sequence.

   Note: Does not work with generators. You may want to explicitly
   convert it to a list:

   .. sourcecode:: jinja

       {{ data | selectattr('name', '==', 'Jinja') | list | last }}


.. py:function:: do_random(context: jinja2.runtime.Context, seq: Sequence[V]) -> Union[V, Undefined]

   Return a random item from the sequence.


.. py:function:: do_filesizeformat(value: Union[str, float, int], binary: bool = False) -> str

   Format the value like a 'human-readable' file size (i.e. 13 kB,
   4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,
   Giga, etc.), if the second parameter is set to `True` the binary
   prefixes are used (Mebi, Gibi).


.. py:function:: do_pprint(value: Any) -> str

   Pretty print a variable. Useful for debugging.


.. py:function:: do_urlize(eval_ctx: jinja2.nodes.EvalContext, value: str, trim_url_limit: Optional[int] = None, nofollow: bool = False, target: Optional[str] = None, rel: Optional[str] = None, extra_schemes: Optional[Iterable[str]] = None) -> str

   Convert URLs in text into clickable links.

   This may not recognize links in some situations. Usually, a more
   comprehensive formatter, such as a Markdown library, is a better
   choice.

   Works on ``http://``, ``https://``, ``www.``, ``mailto:``, and email
   addresses. Links with trailing punctuation (periods, commas, closing
   parentheses) and leading punctuation (opening parentheses) are
   recognized excluding the punctuation. Email addresses that include
   header fields are not recognized (for example,
   ``mailto:address@example.com?cc=copy@example.com``).

   :param value: Original text containing URLs to link.
   :param trim_url_limit: Shorten displayed URL values to this length.
   :param nofollow: Add the ``rel=nofollow`` attribute to links.
   :param target: Add the ``target`` attribute to links.
   :param rel: Add the ``rel`` attribute to links.
   :param extra_schemes: Recognize URLs that start with these schemes
       in addition to the default behavior. Defaults to
       ``env.policies["urlize.extra_schemes"]``, which defaults to no
       extra schemes.

   .. versionchanged:: 3.0
       The ``extra_schemes`` parameter was added.

   .. versionchanged:: 3.0
       Generate ``https://`` links for URLs without a scheme.

   .. versionchanged:: 3.0
       The parsing rules were updated. Recognize email addresses with
       or without the ``mailto:`` scheme. Validate IP addresses. Ignore
       parentheses and brackets in more cases.

   .. versionchanged:: 2.8
      The ``target`` parameter was added.


.. py:function:: do_indent(s: str, width: Union[int, str] = 4, first: bool = False, blank: bool = False) -> str

   Return a copy of the string with each line indented by 4 spaces. The
   first line and blank lines are not indented by default.

   :param width: Number of spaces, or a string, to indent by.
   :param first: Don't skip indenting the first line.
   :param blank: Don't skip indenting empty lines.

   .. versionchanged:: 3.0
       ``width`` can be a string.

   .. versionchanged:: 2.10
       Blank lines are not indented by default.

       Rename the ``indentfirst`` argument to ``first``.


.. py:function:: do_truncate(env: jinja2.environment.Environment, s: str, length: int = 255, killwords: bool = False, end: str = '...', leeway: Optional[int] = None) -> str

   Return a truncated copy of the string. The length is specified
   with the first parameter which defaults to ``255``. If the second
   parameter is ``true`` the filter will cut the text at length. Otherwise
   it will discard the last word. If the text was in fact
   truncated it will append an ellipsis sign (``"..."``). If you want a
   different ellipsis sign than ``"..."`` you can specify it using the
   third parameter. Strings that only exceed the length by the tolerance
   margin given in the fourth parameter will not be truncated.

   .. sourcecode:: jinja

       {{ "foo bar baz qux"|truncate(9) }}
           -> "foo..."
       {{ "foo bar baz qux"|truncate(9, True) }}
           -> "foo ba..."
       {{ "foo bar baz qux"|truncate(11) }}
           -> "foo bar baz qux"
       {{ "foo bar baz qux"|truncate(11, False, '...', 0) }}
           -> "foo bar..."

   The default leeway on newer Jinja versions is 5 and was 0 before but
   can be reconfigured globally.


.. py:function:: do_wordwrap(environment: jinja2.environment.Environment, s: str, width: int = 79, break_long_words: bool = True, wrapstring: Optional[str] = None, break_on_hyphens: bool = True) -> str

   Wrap a string to the given width. Existing newlines are treated
   as paragraphs to be wrapped separately.

   :param s: Original text to wrap.
   :param width: Maximum length of wrapped lines.
   :param break_long_words: If a word is longer than ``width``, break
       it across lines.
   :param break_on_hyphens: If a word contains hyphens, it may be split
       across lines.
   :param wrapstring: String to join each wrapped line. Defaults to
       :attr:`Environment.newline_sequence`.

   .. versionchanged:: 2.11
       Existing newlines are treated as paragraphs wrapped separately.

   .. versionchanged:: 2.11
       Added the ``break_on_hyphens`` parameter.

   .. versionchanged:: 2.7
       Added the ``wrapstring`` parameter.


.. py:function:: do_wordcount(s: str) -> int

   Count the words in that string.


.. py:function:: do_int(value: Any, default: int = 0, base: int = 10) -> int

   Convert the value into an integer. If the
   conversion doesn't work it will return ``0``. You can
   override this default using the first parameter. You
   can also override the default base (10) in the second
   parameter, which handles input with prefixes such as
   0b, 0o and 0x for bases 2, 8 and 16 respectively.
   The base is ignored for decimal numbers and non-string values.


.. py:function:: do_float(value: Any, default: float = 0.0) -> float

   Convert the value into a floating point number. If the
   conversion doesn't work it will return ``0.0``. You can
   override this default using the first parameter.


.. py:function:: do_format(value: str, *args: Any, **kwargs: Any) -> str

   Apply the given values to a `printf-style`_ format string, like
   ``string % values``.

   .. sourcecode:: jinja

       {{ "%s, %s!"|format(greeting, name) }}
       Hello, World!

   In most cases it should be more convenient and efficient to use the
   ``%`` operator or :meth:`str.format`.

   .. code-block:: text

       {{ "%s, %s!" % (greeting, name) }}
       {{ "{}, {}!".format(greeting, name) }}

   .. _printf-style: https://docs.python.org/library/stdtypes.html
       #printf-style-string-formatting


.. py:function:: do_trim(value: str, chars: Optional[str] = None) -> str

   Strip leading and trailing characters, by default whitespace.


.. py:function:: do_striptags(value: Union[str, HasHTML]) -> str

   Strip SGML/XML tags and replace adjacent whitespace by one space.


.. py:function:: sync_do_slice(value: Collection[V], slices: int, fill_with: Optional[V] = None) -> Iterator[t.List[V]]

   Slice an iterator and return a list of lists containing
   those items. Useful if you want to create a div containing
   three ul tags that represent columns:

   .. sourcecode:: html+jinja

       <div class="columnwrapper">
         {%- for column in items|slice(3) %}
           <ul class="column-{{ loop.index }}">
           {%- for item in column %}
             <li>{{ item }}</li>
           {%- endfor %}
           </ul>
         {%- endfor %}
       </div>

   If you pass it a second argument it's used to fill missing
   values on the last iteration.


.. py:function:: do_slice(value: Union[t.AsyncIterable[V], t.Iterable[V]], slices: int, fill_with: Optional[Any] = None) -> Iterator[t.List[V]]
   :async:


.. py:function:: do_batch(value: Iterable[V], linecount: int, fill_with: Optional[V] = None) -> Iterator[t.List[V]]

   A filter that batches items. It works pretty much like `slice`
   just the other way round. It returns a list of lists with the
   given number of items. If you provide a second parameter this
   is used to fill up missing items. See this example:

   .. sourcecode:: html+jinja

       <table>
       {%- for row in items|batch(3, '&nbsp;') %}
         <tr>
         {%- for column in row %}
           <td>{{ column }}</td>
         {%- endfor %}
         </tr>
       {%- endfor %}
       </table>


.. py:function:: do_round(value: float, precision: int = 0, method: typing_extensions.Literal["common", "ceil", "floor"] = 'common') -> float

   Round the number to a given precision. The first
   parameter specifies the precision (default is ``0``), the
   second the rounding method:

   - ``'common'`` rounds either up or down
   - ``'ceil'`` always rounds up
   - ``'floor'`` always rounds down

   If you don't specify a method ``'common'`` is used.

   .. sourcecode:: jinja

       {{ 42.55|round }}
           -> 43.0
       {{ 42.55|round(1, 'floor') }}
           -> 42.5

   Note that even if rounded to 0 precision, a float is returned.  If
   you need a real integer, pipe it through `int`:

   .. sourcecode:: jinja

       {{ 42.55|round|int }}
           -> 43


.. py:function:: sync_do_groupby(environment: jinja2.environment.Environment, value: Iterable[V], attribute: Union[str, int], default: Optional[Any] = None, case_sensitive: bool = False) -> List[_GroupTuple]

   Group a sequence of objects by an attribute using Python's
   :func:`itertools.groupby`. The attribute can use dot notation for
   nested access, like ``"address.city"``. Unlike Python's ``groupby``,
   the values are sorted first so only one group is returned for each
   unique value.

   For example, a list of ``User`` objects with a ``city`` attribute
   can be rendered in groups. In this example, ``grouper`` refers to
   the ``city`` value of the group.

   .. sourcecode:: html+jinja

       <ul>{% for city, items in users|groupby("city") %}
         <li>{{ city }}
           <ul>{% for user in items %}
             <li>{{ user.name }}
           {% endfor %}</ul>
         </li>
       {% endfor %}</ul>

   ``groupby`` yields namedtuples of ``(grouper, list)``, which
   can be used instead of the tuple unpacking above. ``grouper`` is the
   value of the attribute, and ``list`` is the items with that value.

   .. sourcecode:: html+jinja

       <ul>{% for group in users|groupby("city") %}
         <li>{{ group.grouper }}: {{ group.list|join(", ") }}
       {% endfor %}</ul>

   You can specify a ``default`` value to use if an object in the list
   does not have the given attribute.

   .. sourcecode:: jinja

       <ul>{% for city, items in users|groupby("city", default="NY") %}
         <li>{{ city }}: {{ items|map(attribute="name")|join(", ") }}</li>
       {% endfor %}</ul>

   Like the :func:`~jinja-filters.sort` filter, sorting and grouping is
   case-insensitive by default. The ``key`` for each group will have
   the case of the first item in that group of values. For example, if
   a list of users has cities ``["CA", "NY", "ca"]``, the "CA" group
   will have two values. This can be disabled by passing
   ``case_sensitive=True``.

   .. versionchanged:: 3.1
       Added the ``case_sensitive`` parameter. Sorting and grouping is
       case-insensitive by default, matching other filters that do
       comparisons.

   .. versionchanged:: 3.0
       Added the ``default`` parameter.

   .. versionchanged:: 2.6
       The attribute supports dot notation for nested access.


.. py:function:: do_groupby(environment: jinja2.environment.Environment, value: Union[t.AsyncIterable[V], t.Iterable[V]], attribute: Union[str, int], default: Optional[Any] = None, case_sensitive: bool = False) -> List[_GroupTuple]
   :async:


.. py:function:: sync_do_sum(environment: jinja2.environment.Environment, iterable: Iterable[V], attribute: Optional[Union[str, int]] = None, start: V = 0) -> V

   Returns the sum of a sequence of numbers plus the value of parameter
   'start' (which defaults to 0).  When the sequence is empty it returns
   start.

   It is also possible to sum up only certain attributes:

   .. sourcecode:: jinja

       Total: {{ items|sum(attribute='price') }}

   .. versionchanged:: 2.6
      The ``attribute`` parameter was added to allow summing up over
      attributes.  Also the ``start`` parameter was moved on to the right.


.. py:function:: do_sum(environment: jinja2.environment.Environment, iterable: Union[t.AsyncIterable[V], t.Iterable[V]], attribute: Optional[Union[str, int]] = None, start: V = 0) -> V
   :async:


.. py:function:: sync_do_list(value: Iterable[V]) -> List[V]

   Convert the value into a list.  If it was a string the returned list
   will be a list of characters.


.. py:function:: do_list(value: Union[t.AsyncIterable[V], t.Iterable[V]]) -> List[V]
   :async:


.. py:function:: do_mark_safe(value: str) -> markupsafe.Markup

   Mark the value as safe which means that in an environment with automatic
   escaping enabled this variable will not be escaped.


.. py:function:: do_mark_unsafe(value: str) -> str

   Mark a value as unsafe.  This is the reverse operation for :func:`safe`.


.. py:function:: do_reverse(value: str) -> str
                 do_reverse(value: Iterable[V]) -> Iterable[V]

   Reverse the object or return an iterator that iterates over it the other
   way round.


.. py:function:: do_attr(environment: jinja2.environment.Environment, obj: Any, name: str) -> Union[jinja2.runtime.Undefined, Any]

   Get an attribute of an object. ``foo|attr("bar")`` works like
   ``foo.bar``, but returns undefined instead of falling back to ``foo["bar"]``
   if the attribute doesn't exist.

   See :ref:`Notes on subscriptions <notes-on-subscriptions>` for more details.


.. py:function:: sync_do_map(context: jinja2.runtime.Context, value: Iterable[Any], name: str, *args: Any, **kwargs: Any) -> Iterable[Any]
                 sync_do_map(context: jinja2.runtime.Context, value: Iterable[Any], *, attribute: str = ..., default: Optional[Any] = None) -> Iterable[Any]

   Applies a filter on a sequence of objects or looks up an attribute.
   This is useful when dealing with lists of objects but you are really
   only interested in a certain value of it.

   The basic usage is mapping on an attribute.  Imagine you have a list
   of users but you are only interested in a list of usernames:

   .. sourcecode:: jinja

       Users on this page: {{ users|map(attribute='username')|join(', ') }}

   You can specify a ``default`` value to use if an object in the list
   does not have the given attribute.

   .. sourcecode:: jinja

       {{ users|map(attribute="username", default="Anonymous")|join(", ") }}

   Alternatively you can let it invoke a filter by passing the name of the
   filter and the arguments afterwards.  A good example would be applying a
   text conversion filter on a sequence:

   .. sourcecode:: jinja

       Users on this page: {{ titles|map('lower')|join(', ') }}

   Similar to a generator comprehension such as:

   .. code-block:: python

       (u.username for u in users)
       (getattr(u, "username", "Anonymous") for u in users)
       (do_lower(x) for x in titles)

   .. versionchanged:: 2.11.0
       Added the ``default`` parameter.

   .. versionadded:: 2.7


.. py:function:: do_map(context: jinja2.runtime.Context, value: Union[AsyncIterable[Any], Iterable[Any]], name: str, *args: Any, **kwargs: Any) -> Iterable[Any]
                 do_map(context: jinja2.runtime.Context, value: Union[AsyncIterable[Any], Iterable[Any]], *, attribute: str = ..., default: Optional[Any] = None) -> Iterable[Any]

.. py:function:: sync_do_select(context: jinja2.runtime.Context, value: Iterable[V], *args: Any, **kwargs: Any) -> Iterator[V]

   Filters a sequence of objects by applying a test to each object,
   and only selecting the objects with the test succeeding.

   If no test is specified, each object will be evaluated as a boolean.

   Example usage:

   .. sourcecode:: jinja

       {{ numbers|select("odd") }}
       {{ numbers|select("odd") }}
       {{ numbers|select("divisibleby", 3) }}
       {{ numbers|select("lessthan", 42) }}
       {{ strings|select("equalto", "mystring") }}

   Similar to a generator comprehension such as:

   .. code-block:: python

       (n for n in numbers if test_odd(n))
       (n for n in numbers if test_divisibleby(n, 3))

   .. versionadded:: 2.7


.. py:function:: do_select(context: jinja2.runtime.Context, value: Union[t.AsyncIterable[V], t.Iterable[V]], *args: Any, **kwargs: Any) -> AsyncIterator[V]
   :async:


.. py:function:: sync_do_reject(context: jinja2.runtime.Context, value: Iterable[V], *args: Any, **kwargs: Any) -> Iterator[V]

   Filters a sequence of objects by applying a test to each object,
   and rejecting the objects with the test succeeding.

   If no test is specified, each object will be evaluated as a boolean.

   Example usage:

   .. sourcecode:: jinja

       {{ numbers|reject("odd") }}

   Similar to a generator comprehension such as:

   .. code-block:: python

       (n for n in numbers if not test_odd(n))

   .. versionadded:: 2.7


.. py:function:: do_reject(context: jinja2.runtime.Context, value: Union[t.AsyncIterable[V], t.Iterable[V]], *args: Any, **kwargs: Any) -> AsyncIterator[V]
   :async:


.. py:function:: sync_do_selectattr(context: jinja2.runtime.Context, value: Iterable[V], *args: Any, **kwargs: Any) -> Iterator[V]

   Filters a sequence of objects by applying a test to the specified
   attribute of each object, and only selecting the objects with the
   test succeeding.

   If no test is specified, the attribute's value will be evaluated as
   a boolean.

   Example usage:

   .. sourcecode:: jinja

       {{ users|selectattr("is_active") }}
       {{ users|selectattr("email", "none") }}

   Similar to a generator comprehension such as:

   .. code-block:: python

       (user for user in users if user.is_active)
       (user for user in users if test_none(user.email))

   .. versionadded:: 2.7


.. py:function:: do_selectattr(context: jinja2.runtime.Context, value: Union[t.AsyncIterable[V], t.Iterable[V]], *args: Any, **kwargs: Any) -> AsyncIterator[V]
   :async:


.. py:function:: sync_do_rejectattr(context: jinja2.runtime.Context, value: Iterable[V], *args: Any, **kwargs: Any) -> Iterator[V]

   Filters a sequence of objects by applying a test to the specified
   attribute of each object, and rejecting the objects with the test
   succeeding.

   If no test is specified, the attribute's value will be evaluated as
   a boolean.

   .. sourcecode:: jinja

       {{ users|rejectattr("is_active") }}
       {{ users|rejectattr("email", "none") }}

   Similar to a generator comprehension such as:

   .. code-block:: python

       (user for user in users if not user.is_active)
       (user for user in users if not test_none(user.email))

   .. versionadded:: 2.7


.. py:function:: do_rejectattr(context: jinja2.runtime.Context, value: Union[t.AsyncIterable[V], t.Iterable[V]], *args: Any, **kwargs: Any) -> AsyncIterator[V]
   :async:


.. py:function:: do_tojson(eval_ctx: jinja2.nodes.EvalContext, value: Any, indent: Optional[int] = None) -> markupsafe.Markup

   Serialize an object to a string of JSON, and mark it safe to
   render in HTML. This filter is only for use in HTML documents.

   The returned string is safe to render in HTML documents and
   ``<script>`` tags. The exception is in HTML attributes that are
   double quoted; either use single quotes or the ``|forceescape``
   filter.

   :param value: The object to serialize to JSON.
   :param indent: The ``indent`` parameter passed to ``dumps``, for
       pretty-printing the value.

   .. versionadded:: 2.9


.. py:function:: prepare_map(context: jinja2.runtime.Context, args: Tuple[Any, Ellipsis], kwargs: Dict[str, Any]) -> Callable[[Any], Any]

.. py:function:: prepare_select_or_reject(context: jinja2.runtime.Context, args: Tuple[Any, Ellipsis], kwargs: Dict[str, Any], modfunc: Callable[[Any], Any], lookup_attr: bool) -> Callable[[Any], Any]

.. py:function:: select_or_reject(context: jinja2.runtime.Context, value: Iterable[V], args: Tuple[Any, Ellipsis], kwargs: Dict[str, Any], modfunc: Callable[[Any], Any], lookup_attr: bool) -> Iterator[V]

.. py:function:: async_select_or_reject(context: jinja2.runtime.Context, value: Union[t.AsyncIterable[V], t.Iterable[V]], args: Tuple[Any, Ellipsis], kwargs: Dict[str, Any], modfunc: Callable[[Any], Any], lookup_attr: bool) -> AsyncIterator[V]
   :async:


.. py:data:: FILTERS

