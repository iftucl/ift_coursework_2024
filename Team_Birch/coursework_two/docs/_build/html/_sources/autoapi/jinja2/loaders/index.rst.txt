jinja2.loaders
==============

.. py:module:: jinja2.loaders

.. autoapi-nested-parse::

   API and implementations for loading templates from different data
   sources.



Classes
-------

.. autoapisummary::

   jinja2.loaders.BaseLoader
   jinja2.loaders.FileSystemLoader
   jinja2.loaders.PackageLoader
   jinja2.loaders.DictLoader
   jinja2.loaders.FunctionLoader
   jinja2.loaders.PrefixLoader
   jinja2.loaders.ChoiceLoader
   jinja2.loaders.ModuleLoader


Functions
---------

.. autoapisummary::

   jinja2.loaders.split_template_path


Module Contents
---------------

.. py:function:: split_template_path(template: str) -> List[str]

   Split a path into segments and perform a sanity check.  If it detects
   '..' in the path it will raise a `TemplateNotFound` error.


.. py:class:: BaseLoader

   Baseclass for all loaders.  Subclass this and override `get_source` to
   implement a custom loading mechanism.  The environment provides a
   `get_template` method that calls the loader's `load` method to get the
   :class:`Template` object.

   A very basic example for a loader that looks up templates on the file
   system could look like this::

       from jinja2 import BaseLoader, TemplateNotFound
       from os.path import join, exists, getmtime

       class MyLoader(BaseLoader):

           def __init__(self, path):
               self.path = path

           def get_source(self, environment, template):
               path = join(self.path, template)
               if not exists(path):
                   raise TemplateNotFound(template)
               mtime = getmtime(path)
               with open(path) as f:
                   source = f.read()
               return source, path, lambda: mtime == getmtime(path)


   .. py:attribute:: has_source_access
      :value: True



   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



   .. py:method:: list_templates() -> List[str]

      Iterates over all templates.  If the loader does not support that
      it should raise a :exc:`TypeError` which is the default behavior.



   .. py:method:: load(environment: jinja2.environment.Environment, name: str, globals: Optional[MutableMapping[str, Any]] = None) -> jinja2.environment.Template

      Loads a template.  This method looks up the template in the cache
      or loads one by calling :meth:`get_source`.  Subclasses should not
      override this method as loaders working on collections of other
      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
      will not call this method but `get_source` directly.



.. py:class:: FileSystemLoader(searchpath: Union[str, os.PathLike[str], Sequence[Union[str, os.PathLike[str]]]], encoding: str = 'utf-8', followlinks: bool = False)

   Bases: :py:obj:`BaseLoader`


   Load templates from a directory in the file system.

   The path can be relative or absolute. Relative paths are relative to
   the current working directory.

   .. code-block:: python

       loader = FileSystemLoader("templates")

   A list of paths can be given. The directories will be searched in
   order, stopping at the first matching template.

   .. code-block:: python

       loader = FileSystemLoader(["/override/templates", "/default/templates"])

   :param searchpath: A path, or list of paths, to the directory that
       contains the templates.
   :param encoding: Use this encoding to read the text from template
       files.
   :param followlinks: Follow symbolic links in the path.

   .. versionchanged:: 2.8
       Added the ``followlinks`` parameter.


   .. py:attribute:: searchpath


   .. py:attribute:: encoding
      :value: 'utf-8'



   .. py:attribute:: followlinks
      :value: False



   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, str, Callable[[], bool]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



   .. py:method:: list_templates() -> List[str]

      Iterates over all templates.  If the loader does not support that
      it should raise a :exc:`TypeError` which is the default behavior.



.. py:class:: PackageLoader(package_name: str, package_path: str = 'templates', encoding: str = 'utf-8')

   Bases: :py:obj:`BaseLoader`


   Load templates from a directory in a Python package.

   :param package_name: Import name of the package that contains the
       template directory.
   :param package_path: Directory within the imported package that
       contains the templates.
   :param encoding: Encoding of template files.

   The following example looks up templates in the ``pages`` directory
   within the ``project.ui`` package.

   .. code-block:: python

       loader = PackageLoader("project.ui", "pages")

   Only packages installed as directories (standard pip behavior) or
   zip/egg files (less common) are supported. The Python API for
   introspecting data in packages is too limited to support other
   installation methods the way this loader requires.

   There is limited support for :pep:`420` namespace packages. The
   template directory is assumed to only be in one namespace
   contributor. Zip files contributing to a namespace are not
   supported.

   .. versionchanged:: 3.0
       No longer uses ``setuptools`` as a dependency.

   .. versionchanged:: 3.0
       Limited PEP 420 namespace package support.


   .. py:attribute:: package_path
      :value: b''



   .. py:attribute:: package_name


   .. py:attribute:: encoding
      :value: 'utf-8'



   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, str, Optional[Callable[[], bool]]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



   .. py:method:: list_templates() -> List[str]

      Iterates over all templates.  If the loader does not support that
      it should raise a :exc:`TypeError` which is the default behavior.



.. py:class:: DictLoader(mapping: Mapping[str, str])

   Bases: :py:obj:`BaseLoader`


   Loads a template from a Python dict mapping template names to
   template source.  This loader is useful for unittesting:

   >>> loader = DictLoader({'index.html': 'source here'})

   Because auto reloading is rarely useful this is disabled by default.


   .. py:attribute:: mapping


   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, None, Callable[[], bool]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



   .. py:method:: list_templates() -> List[str]

      Iterates over all templates.  If the loader does not support that
      it should raise a :exc:`TypeError` which is the default behavior.



.. py:class:: FunctionLoader(load_func: Callable[[str], Optional[Union[str, Tuple[str, Optional[str], Optional[Callable[[], bool]]]]]])

   Bases: :py:obj:`BaseLoader`


   A loader that is passed a function which does the loading.  The
   function receives the name of the template and has to return either
   a string with the template source, a tuple in the form ``(source,
   filename, uptodatefunc)`` or `None` if the template does not exist.

   >>> def load_template(name):
   ...     if name == 'index.html':
   ...         return '...'
   ...
   >>> loader = FunctionLoader(load_template)

   The `uptodatefunc` is a function that is called if autoreload is enabled
   and has to return `True` if the template is still up to date.  For more
   details have a look at :meth:`BaseLoader.get_source` which has the same
   return value.


   .. py:attribute:: load_func


   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



.. py:class:: PrefixLoader(mapping: Mapping[str, BaseLoader], delimiter: str = '/')

   Bases: :py:obj:`BaseLoader`


   A loader that is passed a dict of loaders where each loader is bound
   to a prefix.  The prefix is delimited from the template by a slash per
   default, which can be changed by setting the `delimiter` argument to
   something else::

       loader = PrefixLoader({
           'app1':     PackageLoader('mypackage.app1'),
           'app2':     PackageLoader('mypackage.app2')
       })

   By loading ``'app1/index.html'`` the file from the app1 package is loaded,
   by loading ``'app2/index.html'`` the file from the second.


   .. py:attribute:: mapping


   .. py:attribute:: delimiter
      :value: '/'



   .. py:method:: get_loader(template: str) -> Tuple[BaseLoader, str]


   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



   .. py:method:: load(environment: jinja2.environment.Environment, name: str, globals: Optional[MutableMapping[str, Any]] = None) -> jinja2.environment.Template

      Loads a template.  This method looks up the template in the cache
      or loads one by calling :meth:`get_source`.  Subclasses should not
      override this method as loaders working on collections of other
      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
      will not call this method but `get_source` directly.



   .. py:method:: list_templates() -> List[str]

      Iterates over all templates.  If the loader does not support that
      it should raise a :exc:`TypeError` which is the default behavior.



.. py:class:: ChoiceLoader(loaders: Sequence[BaseLoader])

   Bases: :py:obj:`BaseLoader`


   This loader works like the `PrefixLoader` just that no prefix is
   specified.  If a template could not be found by one loader the next one
   is tried.

   >>> loader = ChoiceLoader([
   ...     FileSystemLoader('/path/to/user/templates'),
   ...     FileSystemLoader('/path/to/system/templates')
   ... ])

   This is useful if you want to allow users to override builtin templates
   from a different location.


   .. py:attribute:: loaders


   .. py:method:: get_source(environment: jinja2.environment.Environment, template: str) -> Tuple[str, Optional[str], Optional[Callable[[], bool]]]

      Get the template source, filename and reload helper for a template.
      It's passed the environment and template name and has to return a
      tuple in the form ``(source, filename, uptodate)`` or raise a
      `TemplateNotFound` error if it can't locate the template.

      The source part of the returned tuple must be the source of the
      template as a string. The filename should be the name of the
      file on the filesystem if it was loaded from there, otherwise
      ``None``. The filename is used by Python for the tracebacks
      if no loader extension is used.

      The last item in the tuple is the `uptodate` function.  If auto
      reloading is enabled it's always called to check if the template
      changed.  No arguments are passed so the function must store the
      old state somewhere (for example in a closure).  If it returns `False`
      the template will be reloaded.



   .. py:method:: load(environment: jinja2.environment.Environment, name: str, globals: Optional[MutableMapping[str, Any]] = None) -> jinja2.environment.Template

      Loads a template.  This method looks up the template in the cache
      or loads one by calling :meth:`get_source`.  Subclasses should not
      override this method as loaders working on collections of other
      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
      will not call this method but `get_source` directly.



   .. py:method:: list_templates() -> List[str]

      Iterates over all templates.  If the loader does not support that
      it should raise a :exc:`TypeError` which is the default behavior.



.. py:class:: ModuleLoader(path: Union[str, os.PathLike[str], Sequence[Union[str, os.PathLike[str]]]])

   Bases: :py:obj:`BaseLoader`


   This loader loads templates from precompiled templates.

   Example usage:

   >>> loader = ModuleLoader('/path/to/compiled/templates')

   Templates can be precompiled with :meth:`Environment.compile_templates`.


   .. py:attribute:: has_source_access
      :value: False



   .. py:attribute:: module


   .. py:attribute:: package_name


   .. py:method:: get_template_key(name: str) -> str
      :staticmethod:



   .. py:method:: get_module_filename(name: str) -> str
      :staticmethod:



   .. py:method:: load(environment: jinja2.environment.Environment, name: str, globals: Optional[MutableMapping[str, Any]] = None) -> jinja2.environment.Template

      Loads a template.  This method looks up the template in the cache
      or loads one by calling :meth:`get_source`.  Subclasses should not
      override this method as loaders working on collections of other
      loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)
      will not call this method but `get_source` directly.



