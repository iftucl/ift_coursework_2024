jinja2.nodes
============

.. py:module:: jinja2.nodes

.. autoapi-nested-parse::

   AST nodes generated by the parser for the compiler. Also provides
   some node tree helper functions used by the parser and compiler in order
   to normalize nodes.



Exceptions
----------

.. autoapisummary::

   jinja2.nodes.Impossible


Classes
-------

.. autoapisummary::

   jinja2.nodes.NodeType
   jinja2.nodes.EvalContext
   jinja2.nodes.Node
   jinja2.nodes.Stmt
   jinja2.nodes.Helper
   jinja2.nodes.Template
   jinja2.nodes.Output
   jinja2.nodes.Extends
   jinja2.nodes.For
   jinja2.nodes.If
   jinja2.nodes.Macro
   jinja2.nodes.CallBlock
   jinja2.nodes.FilterBlock
   jinja2.nodes.With
   jinja2.nodes.Block
   jinja2.nodes.Include
   jinja2.nodes.Import
   jinja2.nodes.FromImport
   jinja2.nodes.ExprStmt
   jinja2.nodes.Assign
   jinja2.nodes.AssignBlock
   jinja2.nodes.Expr
   jinja2.nodes.BinExpr
   jinja2.nodes.UnaryExpr
   jinja2.nodes.Name
   jinja2.nodes.NSRef
   jinja2.nodes.Literal
   jinja2.nodes.Const
   jinja2.nodes.TemplateData
   jinja2.nodes.Tuple
   jinja2.nodes.List
   jinja2.nodes.Dict
   jinja2.nodes.Pair
   jinja2.nodes.Keyword
   jinja2.nodes.CondExpr
   jinja2.nodes.Filter
   jinja2.nodes.Test
   jinja2.nodes.Call
   jinja2.nodes.Getitem
   jinja2.nodes.Getattr
   jinja2.nodes.Slice
   jinja2.nodes.Concat
   jinja2.nodes.Compare
   jinja2.nodes.Operand
   jinja2.nodes.Mul
   jinja2.nodes.Div
   jinja2.nodes.FloorDiv
   jinja2.nodes.Add
   jinja2.nodes.Sub
   jinja2.nodes.Mod
   jinja2.nodes.Pow
   jinja2.nodes.And
   jinja2.nodes.Or
   jinja2.nodes.Not
   jinja2.nodes.Neg
   jinja2.nodes.Pos
   jinja2.nodes.EnvironmentAttribute
   jinja2.nodes.ExtensionAttribute
   jinja2.nodes.ImportedName
   jinja2.nodes.InternalName
   jinja2.nodes.MarkSafe
   jinja2.nodes.MarkSafeIfAutoescape
   jinja2.nodes.ContextReference
   jinja2.nodes.DerivedContextReference
   jinja2.nodes.Continue
   jinja2.nodes.Break
   jinja2.nodes.Scope
   jinja2.nodes.OverlayScope
   jinja2.nodes.EvalContextModifier
   jinja2.nodes.ScopedEvalContextModifier


Functions
---------

.. autoapisummary::

   jinja2.nodes.get_eval_context
   jinja2.nodes.args_as_const


Module Contents
---------------

.. py:exception:: Impossible

   Bases: :py:obj:`Exception`


   Raised if the node could not perform a requested action.


.. py:class:: NodeType

   Bases: :py:obj:`type`


   A metaclass for nodes that handles the field and attribute
   inheritance.  fields and attributes from the parent class are
   automatically forwarded to the child.


.. py:class:: EvalContext(environment: jinja2.environment.Environment, template_name: Optional[str] = None)

   Holds evaluation time information.  Custom attributes can be attached
   to it in extensions.


   .. py:attribute:: environment


   .. py:attribute:: volatile
      :value: False



   .. py:method:: save() -> Mapping[str, Any]


   .. py:method:: revert(old: Mapping[str, Any]) -> None


.. py:function:: get_eval_context(node: Node, ctx: Optional[EvalContext]) -> EvalContext

.. py:class:: Node(*fields: Any, **attributes: Any)

   Baseclass for all Jinja nodes.  There are a number of nodes available
   of different types.  There are four major types:

   -   :class:`Stmt`: statements
   -   :class:`Expr`: expressions
   -   :class:`Helper`: helper nodes
   -   :class:`Template`: the outermost wrapper node

   All nodes have fields and attributes.  Fields may be other nodes, lists,
   or arbitrary values.  Fields are passed to the constructor as regular
   positional arguments, attributes as keyword arguments.  Each node has
   two attributes: `lineno` (the line number of the node) and `environment`.
   The `environment` attribute is set at the end of the parsing process for
   all nodes automatically.


   .. py:attribute:: fields
      :type:  Tuple[str, Ellipsis]
      :value: ()



   .. py:attribute:: attributes
      :type:  Tuple[str, Ellipsis]
      :value: ('lineno', 'environment')



   .. py:attribute:: abstract
      :value: True



   .. py:attribute:: lineno
      :type:  int


   .. py:attribute:: environment
      :type:  Optional[jinja2.environment.Environment]


   .. py:method:: iter_fields(exclude: Optional[Container[str]] = None, only: Optional[Container[str]] = None) -> Iterator[Tuple[str, Any]]

      This method iterates over all fields that are defined and yields
      ``(key, value)`` tuples.  Per default all fields are returned, but
      it's possible to limit that to some fields by providing the `only`
      parameter or to exclude some using the `exclude` parameter.  Both
      should be sets or tuples of field names.



   .. py:method:: iter_child_nodes(exclude: Optional[Container[str]] = None, only: Optional[Container[str]] = None) -> Iterator[Node]

      Iterates over all direct child nodes of the node.  This iterates
      over all fields and yields the values of they are nodes.  If the value
      of a field is a list all the nodes in that list are returned.



   .. py:method:: find(node_type: Type[_NodeBound]) -> Optional[_NodeBound]

      Find the first node of a given type.  If no such node exists the
      return value is `None`.



   .. py:method:: find_all(node_type: Union[Type[_NodeBound], Tuple[Type[_NodeBound], Ellipsis]]) -> Iterator[_NodeBound]

      Find all the nodes of a given type.  If the type is a tuple,
      the check is performed for any of the tuple items.



   .. py:method:: set_ctx(ctx: str) -> Node

      Reset the context of a node and all child nodes.  Per default the
      parser will all generate nodes that have a 'load' context as it's the
      most common one.  This method is used in the parser to set assignment
      targets and other nodes to a store context.



   .. py:method:: set_lineno(lineno: int, override: bool = False) -> Node

      Set the line numbers of the node and children.



   .. py:method:: set_environment(environment: jinja2.environment.Environment) -> Node

      Set the environment for all nodes.



   .. py:method:: dump() -> str


.. py:class:: Stmt(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Node`


   Base node for all statements.


   .. py:attribute:: abstract
      :value: True



.. py:class:: Helper(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Node`


   Nodes that exist in a specific context only.


   .. py:attribute:: abstract
      :value: True



.. py:class:: Template(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Node`


   Node that represents a template.  This must be the outermost node that
   is passed to the compiler.


   .. py:attribute:: fields
      :value: ('body',)



   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: Output(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A node that holds multiple expressions which are then printed out.
   This is used both for the `print` statement and the regular template data.


   .. py:attribute:: fields
      :value: ('nodes',)



   .. py:attribute:: nodes
      :type:  List[Expr]


.. py:class:: Extends(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Represents an extends statement.


   .. py:attribute:: fields
      :value: ('template',)



   .. py:attribute:: template
      :type:  Expr


.. py:class:: For(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   The for loop.  `target` is the target for the iteration (usually a
   :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list
   of nodes that are used as loop-body, and `else_` a list of nodes for the
   `else` block.  If no else node exists it has to be an empty list.

   For filtered nodes an expression can be stored as `test`, otherwise `None`.


   .. py:attribute:: fields
      :value: ('target', 'iter', 'body', 'else_', 'test', 'recursive')



   .. py:attribute:: target
      :type:  Node


   .. py:attribute:: iter
      :type:  Node


   .. py:attribute:: body
      :type:  List[Node]


   .. py:attribute:: else_
      :type:  List[Node]


   .. py:attribute:: test
      :type:  Optional[Node]


   .. py:attribute:: recursive
      :type:  bool


.. py:class:: If(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   If `test` is true, `body` is rendered, else `else_`.


   .. py:attribute:: fields
      :value: ('test', 'body', 'elif_', 'else_')



   .. py:attribute:: test
      :type:  Node


   .. py:attribute:: body
      :type:  List[Node]


   .. py:attribute:: elif_
      :type:  List[If]


   .. py:attribute:: else_
      :type:  List[Node]


.. py:class:: Macro(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A macro definition.  `name` is the name of the macro, `args` a list of
   arguments and `defaults` a list of defaults if there are any.  `body` is
   a list of nodes for the macro body.


   .. py:attribute:: fields
      :value: ('name', 'args', 'defaults', 'body')



   .. py:attribute:: name
      :type:  str


   .. py:attribute:: args
      :type:  List[Name]


   .. py:attribute:: defaults
      :type:  List[Expr]


   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: CallBlock(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Like a macro without a name but a call instead.  `call` is called with
   the unnamed macro as `caller` argument this node holds.


   .. py:attribute:: fields
      :value: ('call', 'args', 'defaults', 'body')



   .. py:attribute:: call
      :type:  Call


   .. py:attribute:: args
      :type:  List[Name]


   .. py:attribute:: defaults
      :type:  List[Expr]


   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: FilterBlock(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Node for filter sections.


   .. py:attribute:: fields
      :value: ('body', 'filter')



   .. py:attribute:: body
      :type:  List[Node]


   .. py:attribute:: filter
      :type:  Filter


.. py:class:: With(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Specific node for with statements.  In older versions of Jinja the
   with statement was implemented on the base of the `Scope` node instead.

   .. versionadded:: 2.9.3


   .. py:attribute:: fields
      :value: ('targets', 'values', 'body')



   .. py:attribute:: targets
      :type:  List[Expr]


   .. py:attribute:: values
      :type:  List[Expr]


   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: Block(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A node that represents a block.

   .. versionchanged:: 3.0.0
       the `required` field was added.


   .. py:attribute:: fields
      :value: ('name', 'body', 'scoped', 'required')



   .. py:attribute:: name
      :type:  str


   .. py:attribute:: body
      :type:  List[Node]


   .. py:attribute:: scoped
      :type:  bool


   .. py:attribute:: required
      :type:  bool


.. py:class:: Include(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A node that represents the include tag.


   .. py:attribute:: fields
      :value: ('template', 'with_context', 'ignore_missing')



   .. py:attribute:: template
      :type:  Expr


   .. py:attribute:: with_context
      :type:  bool


   .. py:attribute:: ignore_missing
      :type:  bool


.. py:class:: Import(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A node that represents the import tag.


   .. py:attribute:: fields
      :value: ('template', 'target', 'with_context')



   .. py:attribute:: template
      :type:  Expr


   .. py:attribute:: target
      :type:  str


   .. py:attribute:: with_context
      :type:  bool


.. py:class:: FromImport(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A node that represents the from import tag.  It's important to not
   pass unsafe names to the name attribute.  The compiler translates the
   attribute lookups directly into getattr calls and does *not* use the
   subscript callback of the interface.  As exported variables may not
   start with double underscores (which the parser asserts) this is not a
   problem for regular Jinja code, but if this node is used in an extension
   extra care must be taken.

   The list of names may contain tuples if aliases are wanted.


   .. py:attribute:: fields
      :value: ('template', 'names', 'with_context')



   .. py:attribute:: template
      :type:  Expr


   .. py:attribute:: names
      :type:  List[Union[str, Tuple[str, str]]]


   .. py:attribute:: with_context
      :type:  bool


.. py:class:: ExprStmt(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   A statement that evaluates an expression and discards the result.


   .. py:attribute:: fields
      :value: ('node',)



   .. py:attribute:: node
      :type:  Node


.. py:class:: Assign(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Assigns an expression to a target.


   .. py:attribute:: fields
      :value: ('target', 'node')



   .. py:attribute:: target
      :type:  Expr


   .. py:attribute:: node
      :type:  Node


.. py:class:: AssignBlock(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Assigns a block to a target.


   .. py:attribute:: fields
      :value: ('target', 'filter', 'body')



   .. py:attribute:: target
      :type:  Expr


   .. py:attribute:: filter
      :type:  Optional[Filter]


   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: Expr(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Node`


   Baseclass for all expressions.


   .. py:attribute:: abstract
      :value: True



   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



   .. py:method:: can_assign() -> bool

      Check if it's possible to assign something to this node.



.. py:class:: BinExpr(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Baseclass for all binary expressions.


   .. py:attribute:: fields
      :value: ('left', 'right')



   .. py:attribute:: left
      :type:  Expr


   .. py:attribute:: right
      :type:  Expr


   .. py:attribute:: operator
      :type:  str


   .. py:attribute:: abstract
      :value: True



   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: UnaryExpr(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Baseclass for all unary expressions.


   .. py:attribute:: fields
      :value: ('node',)



   .. py:attribute:: node
      :type:  Expr


   .. py:attribute:: operator
      :type:  str


   .. py:attribute:: abstract
      :value: True



   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Name(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Looks up a name or stores a value in a name.
   The `ctx` of the node can be one of the following values:

   -   `store`: store a value in the name
   -   `load`: load that name
   -   `param`: like `store` but if the name was defined as function parameter.


   .. py:attribute:: fields
      :value: ('name', 'ctx')



   .. py:attribute:: name
      :type:  str


   .. py:attribute:: ctx
      :type:  str


   .. py:method:: can_assign() -> bool

      Check if it's possible to assign something to this node.



.. py:class:: NSRef(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Reference to a namespace value assignment


   .. py:attribute:: fields
      :value: ('name', 'attr')



   .. py:attribute:: name
      :type:  str


   .. py:attribute:: attr
      :type:  str


   .. py:method:: can_assign() -> bool

      Check if it's possible to assign something to this node.



.. py:class:: Literal(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Baseclass for literals.


   .. py:attribute:: abstract
      :value: True



.. py:class:: Const(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Literal`


   All constant values.  The parser will return this node for simple
   constants such as ``42`` or ``"foo"`` but it can be used to store more
   complex values such as lists too.  Only constants with a safe
   representation (objects where ``eval(repr(x)) == x`` is true).


   .. py:attribute:: fields
      :value: ('value',)



   .. py:attribute:: value
      :type:  Any


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



   .. py:method:: from_untrusted(value: Any, lineno: Optional[int] = None, environment: Optional[Environment] = None) -> Const
      :classmethod:


      Return a const object if the value is representable as
      constant value in the generated code, otherwise it will raise
      an `Impossible` exception.



.. py:class:: TemplateData(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Literal`


   A constant template string.


   .. py:attribute:: fields
      :value: ('data',)



   .. py:attribute:: data
      :type:  str


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> str

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Tuple(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Literal`


   For loop unpacking and some other things like multiple arguments
   for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple
   is used for loading the names or storing.


   .. py:attribute:: fields
      :value: ('items', 'ctx')



   .. py:attribute:: items
      :type:  List[Expr]


   .. py:attribute:: ctx
      :type:  str


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Tuple[Any, Ellipsis]

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



   .. py:method:: can_assign() -> bool

      Check if it's possible to assign something to this node.



.. py:class:: List(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Literal`


   Any list literal such as ``[1, 2, 3]``


   .. py:attribute:: fields
      :value: ('items',)



   .. py:attribute:: items
      :type:  List[Expr]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> List[Any]

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Dict(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Literal`


   Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of
   :class:`Pair` nodes.


   .. py:attribute:: fields
      :value: ('items',)



   .. py:attribute:: items
      :type:  List[Pair]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Dict[Any, Any]

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Pair(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Helper`


   A key, value pair for dicts.


   .. py:attribute:: fields
      :value: ('key', 'value')



   .. py:attribute:: key
      :type:  Expr


   .. py:attribute:: value
      :type:  Expr


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Tuple[Any, Any]


.. py:class:: Keyword(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Helper`


   A key, value pair for keyword arguments where key is a string.


   .. py:attribute:: fields
      :value: ('key', 'value')



   .. py:attribute:: key
      :type:  str


   .. py:attribute:: value
      :type:  Expr


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Tuple[str, Any]


.. py:class:: CondExpr(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   A conditional expression (inline if expression).  (``{{
   foo if bar else baz }}``)


   .. py:attribute:: fields
      :value: ('test', 'expr1', 'expr2')



   .. py:attribute:: test
      :type:  Expr


   .. py:attribute:: expr1
      :type:  Expr


   .. py:attribute:: expr2
      :type:  Optional[Expr]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:function:: args_as_const(node: Union[_FilterTestCommon, Call], eval_ctx: Optional[EvalContext]) -> Tuple[List[Any], Dict[Any, Any]]

.. py:class:: Filter(*fields: Any, **attributes: Any)

   Bases: :py:obj:`_FilterTestCommon`


   Apply a filter to an expression. ``name`` is the name of the
   filter, the other fields are the same as :class:`Call`.

   If ``node`` is ``None``, the filter is being used in a filter block
   and is applied to the content of the block.


   .. py:attribute:: node
      :type:  Optional[Expr]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Test(*fields: Any, **attributes: Any)

   Bases: :py:obj:`_FilterTestCommon`


   Apply a test to an expression. ``name`` is the name of the test,
   the other field are the same as :class:`Call`.

   .. versionchanged:: 3.0
       ``as_const`` shares the same logic for filters and tests. Tests
       check for volatile, async, and ``@pass_context`` etc.
       decorators.


.. py:class:: Call(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Calls an expression.  `args` is a list of arguments, `kwargs` a list
   of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`
   and `dyn_kwargs` has to be either `None` or a node that is used as
   node for dynamic positional (``*args``) or keyword (``**kwargs``)
   arguments.


   .. py:attribute:: fields
      :value: ('node', 'args', 'kwargs', 'dyn_args', 'dyn_kwargs')



   .. py:attribute:: node
      :type:  Expr


   .. py:attribute:: args
      :type:  List[Expr]


   .. py:attribute:: kwargs
      :type:  List[Keyword]


   .. py:attribute:: dyn_args
      :type:  Optional[Expr]


   .. py:attribute:: dyn_kwargs
      :type:  Optional[Expr]


.. py:class:: Getitem(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Get an attribute or item from an expression and prefer the item.


   .. py:attribute:: fields
      :value: ('node', 'arg', 'ctx')



   .. py:attribute:: node
      :type:  Expr


   .. py:attribute:: arg
      :type:  Expr


   .. py:attribute:: ctx
      :type:  str


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Getattr(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Get an attribute or item from an expression that is a ascii-only
   bytestring and prefer the attribute.


   .. py:attribute:: fields
      :value: ('node', 'attr', 'ctx')



   .. py:attribute:: node
      :type:  Expr


   .. py:attribute:: attr
      :type:  str


   .. py:attribute:: ctx
      :type:  str


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Slice(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Represents a slice object.  This must only be used as argument for
   :class:`Subscript`.


   .. py:attribute:: fields
      :value: ('start', 'stop', 'step')



   .. py:attribute:: start
      :type:  Optional[Expr]


   .. py:attribute:: stop
      :type:  Optional[Expr]


   .. py:attribute:: step
      :type:  Optional[Expr]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> slice

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Concat(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Concatenates the list of expressions provided after converting
   them to strings.


   .. py:attribute:: fields
      :value: ('nodes',)



   .. py:attribute:: nodes
      :type:  List[Expr]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> str

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Compare(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Compares an expression with some other expressions.  `ops` must be a
   list of :class:`Operand`\s.


   .. py:attribute:: fields
      :value: ('expr', 'ops')



   .. py:attribute:: expr
      :type:  Expr


   .. py:attribute:: ops
      :type:  List[Operand]


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Operand(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Helper`


   Holds an operator and an expression.


   .. py:attribute:: fields
      :value: ('op', 'expr')



   .. py:attribute:: op
      :type:  str


   .. py:attribute:: expr
      :type:  Expr


.. py:class:: Mul(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Multiplies the left with the right node.


   .. py:attribute:: operator
      :value: '*'



.. py:class:: Div(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Divides the left by the right node.


   .. py:attribute:: operator
      :value: '/'



.. py:class:: FloorDiv(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Divides the left by the right node and converts the
   result into an integer by truncating.


   .. py:attribute:: operator
      :value: '//'



.. py:class:: Add(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Add the left to the right node.


   .. py:attribute:: operator
      :value: '+'



.. py:class:: Sub(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Subtract the right from the left node.


   .. py:attribute:: operator
      :value: '-'



.. py:class:: Mod(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Left modulo right.


   .. py:attribute:: operator
      :value: '%'



.. py:class:: Pow(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Left to the power of right.


   .. py:attribute:: operator
      :value: '**'



.. py:class:: And(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Short circuited AND.


   .. py:attribute:: operator
      :value: 'and'



   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Or(*fields: Any, **attributes: Any)

   Bases: :py:obj:`BinExpr`


   Short circuited OR.


   .. py:attribute:: operator
      :value: 'or'



   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Any

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: Not(*fields: Any, **attributes: Any)

   Bases: :py:obj:`UnaryExpr`


   Negate the expression.


   .. py:attribute:: operator
      :value: 'not'



.. py:class:: Neg(*fields: Any, **attributes: Any)

   Bases: :py:obj:`UnaryExpr`


   Make the expression negative.


   .. py:attribute:: operator
      :value: '-'



.. py:class:: Pos(*fields: Any, **attributes: Any)

   Bases: :py:obj:`UnaryExpr`


   Make the expression positive (noop for most expressions)


   .. py:attribute:: operator
      :value: '+'



.. py:class:: EnvironmentAttribute(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Loads an attribute from the environment object.  This is useful for
   extensions that want to call a callback stored on the environment.


   .. py:attribute:: fields
      :value: ('name',)



   .. py:attribute:: name
      :type:  str


.. py:class:: ExtensionAttribute(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Returns the attribute of an extension bound to the environment.
   The identifier is the identifier of the :class:`Extension`.

   This node is usually constructed by calling the
   :meth:`~jinja2.ext.Extension.attr` method on an extension.


   .. py:attribute:: fields
      :value: ('identifier', 'name')



   .. py:attribute:: identifier
      :type:  str


   .. py:attribute:: name
      :type:  str


.. py:class:: ImportedName(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   If created with an import name the import name is returned on node
   access.  For example ``ImportedName('cgi.escape')`` returns the `escape`
   function from the cgi module on evaluation.  Imports are optimized by the
   compiler so there is no need to assign them to local variables.


   .. py:attribute:: fields
      :value: ('importname',)



   .. py:attribute:: importname
      :type:  str


.. py:class:: InternalName

   Bases: :py:obj:`Expr`


   An internal name in the compiler.  You cannot create these nodes
   yourself but the parser provides a
   :meth:`~jinja2.parser.Parser.free_identifier` method that creates
   a new identifier for you.  This identifier is not available from the
   template and is not treated specially by the compiler.


   .. py:attribute:: fields
      :value: ('name',)



   .. py:attribute:: name
      :type:  str


.. py:class:: MarkSafe(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Mark the wrapped expression as safe (wrap it as `Markup`).


   .. py:attribute:: fields
      :value: ('expr',)



   .. py:attribute:: expr
      :type:  Expr


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> markupsafe.Markup

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: MarkSafeIfAutoescape(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Mark the wrapped expression as safe (wrap it as `Markup`) but
   only if autoescaping is active.

   .. versionadded:: 2.5


   .. py:attribute:: fields
      :value: ('expr',)



   .. py:attribute:: expr
      :type:  Expr


   .. py:method:: as_const(eval_ctx: Optional[EvalContext] = None) -> Union[markupsafe.Markup, Any]

      Return the value of the expression as constant or raise
      :exc:`Impossible` if this was not possible.

      An :class:`EvalContext` can be provided, if none is given
      a default context is created which requires the nodes to have
      an attached environment.

      .. versionchanged:: 2.4
         the `eval_ctx` parameter was added.



.. py:class:: ContextReference(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Returns the current template context.  It can be used like a
   :class:`Name` node, with a ``'load'`` ctx and will return the
   current :class:`~jinja2.runtime.Context` object.

   Here an example that assigns the current template name to a
   variable named `foo`::

       Assign(Name('foo', ctx='store'),
              Getattr(ContextReference(), 'name'))

   This is basically equivalent to using the
   :func:`~jinja2.pass_context` decorator when using the high-level
   API, which causes a reference to the context to be passed as the
   first argument to a function.


.. py:class:: DerivedContextReference(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Expr`


   Return the current template context including locals. Behaves
   exactly like :class:`ContextReference`, but includes local
   variables, such as from a ``for`` loop.

   .. versionadded:: 2.11


.. py:class:: Continue(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Continue a loop.


.. py:class:: Break(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Break a loop.


.. py:class:: Scope(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   An artificial scope.


   .. py:attribute:: fields
      :value: ('body',)



   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: OverlayScope(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   An overlay scope for extensions.  This is a largely unoptimized scope
   that however can be used to introduce completely arbitrary variables into
   a sub scope from a dictionary or dictionary like object.  The `context`
   field has to evaluate to a dictionary object.

   Example usage::

       OverlayScope(context=self.call_method('get_context'),
                    body=[...])

   .. versionadded:: 2.10


   .. py:attribute:: fields
      :value: ('context', 'body')



   .. py:attribute:: context
      :type:  Expr


   .. py:attribute:: body
      :type:  List[Node]


.. py:class:: EvalContextModifier(*fields: Any, **attributes: Any)

   Bases: :py:obj:`Stmt`


   Modifies the eval context.  For each option that should be modified,
   a :class:`Keyword` has to be added to the :attr:`options` list.

   Example to change the `autoescape` setting::

       EvalContextModifier(options=[Keyword('autoescape', Const(True))])


   .. py:attribute:: fields
      :value: ('options',)



   .. py:attribute:: options
      :type:  List[Keyword]


.. py:class:: ScopedEvalContextModifier(*fields: Any, **attributes: Any)

   Bases: :py:obj:`EvalContextModifier`


   Modifies the eval context and reverts it later.  Works exactly like
   :class:`EvalContextModifier` but will only modify the
   :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.


   .. py:attribute:: fields
      :value: ('body',)



   .. py:attribute:: body
      :type:  List[Node]


