jinja2.parser
=============

.. py:module:: jinja2.parser

.. autoapi-nested-parse::

   Parse tokens from the lexer into nodes for the compiler.



Classes
-------

.. autoapisummary::

   jinja2.parser.Parser


Module Contents
---------------

.. py:class:: Parser(environment: jinja2.environment.Environment, source: str, name: Optional[str] = None, filename: Optional[str] = None, state: Optional[str] = None)

   This is the central parsing class Jinja uses.  It's passed to
   extensions and can be used to parse expressions or statements.


   .. py:attribute:: environment


   .. py:attribute:: stream


   .. py:attribute:: name
      :value: None



   .. py:attribute:: filename
      :value: None



   .. py:attribute:: closed
      :value: False



   .. py:attribute:: extensions
      :type:  Dict[str, Callable[[Parser], Union[jinja2.nodes.Node, List[jinja2.nodes.Node]]]]


   .. py:method:: fail(msg: str, lineno: Optional[int] = None, exc: Type[jinja2.exceptions.TemplateSyntaxError] = TemplateSyntaxError) -> typing_extensions.NoReturn

      Convenience method that raises `exc` with the message, passed
      line number or last line number as well as the current name and
      filename.



   .. py:method:: fail_unknown_tag(name: str, lineno: Optional[int] = None) -> typing_extensions.NoReturn

      Called if the parser encounters an unknown tag.  Tries to fail
      with a human readable error message that could help to identify
      the problem.



   .. py:method:: fail_eof(end_tokens: Optional[Tuple[str, Ellipsis]] = None, lineno: Optional[int] = None) -> typing_extensions.NoReturn

      Like fail_unknown_tag but for end of template situations.



   .. py:method:: is_tuple_end(extra_end_rules: Optional[Tuple[str, Ellipsis]] = None) -> bool

      Are we at the end of a tuple?



   .. py:method:: free_identifier(lineno: Optional[int] = None) -> jinja2.nodes.InternalName

      Return a new free identifier as :class:`~jinja2.nodes.InternalName`.



   .. py:method:: parse_statement() -> Union[jinja2.nodes.Node, List[jinja2.nodes.Node]]

      Parse a single statement.



   .. py:method:: parse_statements(end_tokens: Tuple[str, Ellipsis], drop_needle: bool = False) -> List[jinja2.nodes.Node]

      Parse multiple statements into a list until one of the end tokens
      is reached.  This is used to parse the body of statements as it also
      parses template data if appropriate.  The parser checks first if the
      current token is a colon and skips it if there is one.  Then it checks
      for the block end and parses until if one of the `end_tokens` is
      reached.  Per default the active token in the stream at the end of
      the call is the matched end token.  If this is not wanted `drop_needle`
      can be set to `True` and the end token is removed.



   .. py:method:: parse_set() -> Union[jinja2.nodes.Assign, jinja2.nodes.AssignBlock]

      Parse an assign statement.



   .. py:method:: parse_for() -> jinja2.nodes.For

      Parse a for loop.



   .. py:method:: parse_if() -> jinja2.nodes.If

      Parse an if construct.



   .. py:method:: parse_with() -> jinja2.nodes.With


   .. py:method:: parse_autoescape() -> jinja2.nodes.Scope


   .. py:method:: parse_block() -> jinja2.nodes.Block


   .. py:method:: parse_extends() -> jinja2.nodes.Extends


   .. py:method:: parse_import_context(node: _ImportInclude, default: bool) -> _ImportInclude


   .. py:method:: parse_include() -> jinja2.nodes.Include


   .. py:method:: parse_import() -> jinja2.nodes.Import


   .. py:method:: parse_from() -> jinja2.nodes.FromImport


   .. py:method:: parse_signature(node: _MacroCall) -> None


   .. py:method:: parse_call_block() -> jinja2.nodes.CallBlock


   .. py:method:: parse_filter_block() -> jinja2.nodes.FilterBlock


   .. py:method:: parse_macro() -> jinja2.nodes.Macro


   .. py:method:: parse_print() -> jinja2.nodes.Output


   .. py:method:: parse_assign_target(with_tuple: bool = ..., name_only: typing_extensions.Literal[True] = ...) -> jinja2.nodes.Name
                  parse_assign_target(with_tuple: bool = True, name_only: bool = False, extra_end_rules: Optional[Tuple[str, Ellipsis]] = None, with_namespace: bool = False) -> Union[jinja2.nodes.NSRef, jinja2.nodes.Name, jinja2.nodes.Tuple]

      Parse an assignment target.  As Jinja allows assignments to
      tuples, this function can parse all allowed assignment targets.  Per
      default assignments to tuples are parsed, that can be disable however
      by setting `with_tuple` to `False`.  If only assignments to names are
      wanted `name_only` can be set to `True`.  The `extra_end_rules`
      parameter is forwarded to the tuple parsing function.  If
      `with_namespace` is enabled, a namespace assignment may be parsed.



   .. py:method:: parse_expression(with_condexpr: bool = True) -> jinja2.nodes.Expr

      Parse an expression.  Per default all expressions are parsed, if
      the optional `with_condexpr` parameter is set to `False` conditional
      expressions are not parsed.



   .. py:method:: parse_condexpr() -> jinja2.nodes.Expr


   .. py:method:: parse_or() -> jinja2.nodes.Expr


   .. py:method:: parse_and() -> jinja2.nodes.Expr


   .. py:method:: parse_not() -> jinja2.nodes.Expr


   .. py:method:: parse_compare() -> jinja2.nodes.Expr


   .. py:method:: parse_math1() -> jinja2.nodes.Expr


   .. py:method:: parse_concat() -> jinja2.nodes.Expr


   .. py:method:: parse_math2() -> jinja2.nodes.Expr


   .. py:method:: parse_pow() -> jinja2.nodes.Expr


   .. py:method:: parse_unary(with_filter: bool = True) -> jinja2.nodes.Expr


   .. py:method:: parse_primary(with_namespace: bool = False) -> jinja2.nodes.Expr

      Parse a name or literal value. If ``with_namespace`` is enabled, also
      parse namespace attr refs, for use in assignments.



   .. py:method:: parse_tuple(simplified: bool = False, with_condexpr: bool = True, extra_end_rules: Optional[Tuple[str, Ellipsis]] = None, explicit_parentheses: bool = False, with_namespace: bool = False) -> Union[jinja2.nodes.Tuple, jinja2.nodes.Expr]

      Works like `parse_expression` but if multiple expressions are
      delimited by a comma a :class:`~jinja2.nodes.Tuple` node is created.
      This method could also return a regular expression instead of a tuple
      if no commas where found.

      The default parsing mode is a full tuple.  If `simplified` is `True`
      only names and literals are parsed; ``with_namespace`` allows namespace
      attr refs as well. The `no_condexpr` parameter is forwarded to
      :meth:`parse_expression`.

      Because tuples do not require delimiters and may end in a bogus comma
      an extra hint is needed that marks the end of a tuple.  For example
      for loops support tuples between `for` and `in`.  In that case the
      `extra_end_rules` is set to ``['name:in']``.

      `explicit_parentheses` is true if the parsing was triggered by an
      expression in parentheses.  This is used to figure out if an empty
      tuple is a valid expression or not.



   .. py:method:: parse_list() -> jinja2.nodes.List


   .. py:method:: parse_dict() -> jinja2.nodes.Dict


   .. py:method:: parse_postfix(node: jinja2.nodes.Expr) -> jinja2.nodes.Expr


   .. py:method:: parse_filter_expr(node: jinja2.nodes.Expr) -> jinja2.nodes.Expr


   .. py:method:: parse_subscript(node: jinja2.nodes.Expr) -> Union[jinja2.nodes.Getattr, jinja2.nodes.Getitem]


   .. py:method:: parse_subscribed() -> jinja2.nodes.Expr


   .. py:method:: parse_call_args() -> Tuple[List[jinja2.nodes.Expr], List[jinja2.nodes.Keyword], Optional[jinja2.nodes.Expr], Optional[jinja2.nodes.Expr]]


   .. py:method:: parse_call(node: jinja2.nodes.Expr) -> jinja2.nodes.Call


   .. py:method:: parse_filter(node: Optional[jinja2.nodes.Expr], start_inline: bool = False) -> Optional[jinja2.nodes.Expr]


   .. py:method:: parse_test(node: jinja2.nodes.Expr) -> jinja2.nodes.Expr


   .. py:method:: subparse(end_tokens: Optional[Tuple[str, Ellipsis]] = None) -> List[jinja2.nodes.Node]


   .. py:method:: parse() -> jinja2.nodes.Template

      Parse the whole template into a `Template` node.



