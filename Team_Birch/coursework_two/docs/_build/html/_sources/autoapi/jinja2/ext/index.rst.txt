jinja2.ext
==========

.. py:module:: jinja2.ext

.. autoapi-nested-parse::

   Extension API for adding custom tags and behavior.



Attributes
----------

.. autoapisummary::

   jinja2.ext.GETTEXT_FUNCTIONS
   jinja2.ext.i18n
   jinja2.ext.do
   jinja2.ext.loopcontrols
   jinja2.ext.debug


Classes
-------

.. autoapisummary::

   jinja2.ext.Extension
   jinja2.ext.InternationalizationExtension
   jinja2.ext.ExprStmtExtension
   jinja2.ext.LoopControlExtension
   jinja2.ext.DebugExtension


Functions
---------

.. autoapisummary::

   jinja2.ext.extract_from_ast
   jinja2.ext.babel_extract


Module Contents
---------------

.. py:data:: GETTEXT_FUNCTIONS
   :type:  Tuple[str, Ellipsis]
   :value: ('_', 'gettext', 'ngettext', 'pgettext', 'npgettext')


.. py:class:: Extension(environment: jinja2.environment.Environment)

   Extensions can be used to add extra functionality to the Jinja template
   system at the parser level.  Custom extensions are bound to an environment
   but may not store environment specific data on `self`.  The reason for
   this is that an extension can be bound to another environment (for
   overlays) by creating a copy and reassigning the `environment` attribute.

   As extensions are created by the environment they cannot accept any
   arguments for configuration.  One may want to work around that by using
   a factory function, but that is not possible as extensions are identified
   by their import name.  The correct way to configure the extension is
   storing the configuration values on the environment.  Because this way the
   environment ends up acting as central configuration storage the
   attributes may clash which is why extensions have to ensure that the names
   they choose for configuration are not too generic.  ``prefix`` for example
   is a terrible name, ``fragment_cache_prefix`` on the other hand is a good
   name as includes the name of the extension (fragment cache).


   .. py:attribute:: identifier
      :type:  ClassVar[str]


   .. py:attribute:: tags
      :type:  Set[str]


   .. py:attribute:: priority
      :value: 100



   .. py:attribute:: environment


   .. py:method:: bind(environment: jinja2.environment.Environment) -> typing_extensions.Self

      Create a copy of this extension bound to another environment.



   .. py:method:: preprocess(source: str, name: Optional[str], filename: Optional[str] = None) -> str

      This method is called before the actual lexing and can be used to
      preprocess the source.  The `filename` is optional.  The return value
      must be the preprocessed source.



   .. py:method:: filter_stream(stream: jinja2.lexer.TokenStream) -> Union[jinja2.lexer.TokenStream, Iterable[jinja2.lexer.Token]]

      It's passed a :class:`~jinja2.lexer.TokenStream` that can be used
      to filter tokens returned.  This method has to return an iterable of
      :class:`~jinja2.lexer.Token`\s, but it doesn't have to return a
      :class:`~jinja2.lexer.TokenStream`.



   .. py:method:: parse(parser: jinja2.parser.Parser) -> Union[jinja2.nodes.Node, List[jinja2.nodes.Node]]
      :abstractmethod:


      If any of the :attr:`tags` matched this method is called with the
      parser as first argument.  The token the parser stream is pointing at
      is the name token that matched.  This method has to return one or a
      list of multiple nodes.



   .. py:method:: attr(name: str, lineno: Optional[int] = None) -> jinja2.nodes.ExtensionAttribute

      Return an attribute node for the current extension.  This is useful
      to pass constants on extensions to generated template code.

      ::

          self.attr('_my_attribute', lineno=lineno)



   .. py:method:: call_method(name: str, args: Optional[List[jinja2.nodes.Expr]] = None, kwargs: Optional[List[jinja2.nodes.Keyword]] = None, dyn_args: Optional[jinja2.nodes.Expr] = None, dyn_kwargs: Optional[jinja2.nodes.Expr] = None, lineno: Optional[int] = None) -> jinja2.nodes.Call

      Call a method of the extension.  This is a shortcut for
      :meth:`attr` + :class:`jinja2.nodes.Call`.



.. py:class:: InternationalizationExtension(environment: jinja2.environment.Environment)

   Bases: :py:obj:`Extension`


   This extension adds gettext support to Jinja.


   .. py:attribute:: tags


   .. py:method:: parse(parser: jinja2.parser.Parser) -> Union[jinja2.nodes.Node, List[jinja2.nodes.Node]]

      Parse a translatable tag.



.. py:class:: ExprStmtExtension(environment: jinja2.environment.Environment)

   Bases: :py:obj:`Extension`


   Adds a `do` tag to Jinja that works like the print statement just
   that it doesn't print the return value.


   .. py:attribute:: tags


   .. py:method:: parse(parser: jinja2.parser.Parser) -> jinja2.nodes.ExprStmt

      If any of the :attr:`tags` matched this method is called with the
      parser as first argument.  The token the parser stream is pointing at
      is the name token that matched.  This method has to return one or a
      list of multiple nodes.



.. py:class:: LoopControlExtension(environment: jinja2.environment.Environment)

   Bases: :py:obj:`Extension`


   Adds break and continue to the template engine.


   .. py:attribute:: tags


   .. py:method:: parse(parser: jinja2.parser.Parser) -> Union[jinja2.nodes.Break, jinja2.nodes.Continue]

      If any of the :attr:`tags` matched this method is called with the
      parser as first argument.  The token the parser stream is pointing at
      is the name token that matched.  This method has to return one or a
      list of multiple nodes.



.. py:class:: DebugExtension(environment: jinja2.environment.Environment)

   Bases: :py:obj:`Extension`


   A ``{% debug %}`` tag that dumps the available variables,
   filters, and tests.

   .. code-block:: html+jinja

       <pre>{% debug %}</pre>

   .. code-block:: text

       {'context': {'cycler': <class 'jinja2.utils.Cycler'>,
                    ...,
                    'namespace': <class 'jinja2.utils.Namespace'>},
        'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',
                    ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'],
        'tests': ['!=', '<', '<=', '==', '>', '>=', 'callable', 'defined',
                  ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']}

   .. versionadded:: 2.11.0


   .. py:attribute:: tags


   .. py:method:: parse(parser: jinja2.parser.Parser) -> jinja2.nodes.Output

      If any of the :attr:`tags` matched this method is called with the
      parser as first argument.  The token the parser stream is pointing at
      is the name token that matched.  This method has to return one or a
      list of multiple nodes.



.. py:function:: extract_from_ast(ast: jinja2.nodes.Template, gettext_functions: Sequence[str] = GETTEXT_FUNCTIONS, babel_style: bool = True) -> Iterator[Tuple[int, str, Union[Optional[str], Tuple[Optional[str], Ellipsis]]]]

   Extract localizable strings from the given template node.  Per
   default this function returns matches in babel style that means non string
   parameters as well as keyword arguments are returned as `None`.  This
   allows Babel to figure out what you really meant if you are using
   gettext functions that allow keyword arguments for placeholder expansion.
   If you don't want that behavior set the `babel_style` parameter to `False`
   which causes only strings to be returned and parameters are always stored
   in tuples.  As a consequence invalid gettext calls (calls without a single
   string parameter or string parameters after non-string parameters) are
   skipped.

   This example explains the behavior:

   >>> from jinja2 import Environment
   >>> env = Environment()
   >>> node = env.parse('{{ (_("foo"), _(), ngettext("foo", "bar", 42)) }}')
   >>> list(extract_from_ast(node))
   [(1, '_', 'foo'), (1, '_', ()), (1, 'ngettext', ('foo', 'bar', None))]
   >>> list(extract_from_ast(node, babel_style=False))
   [(1, '_', ('foo',)), (1, 'ngettext', ('foo', 'bar'))]

   For every string found this function yields a ``(lineno, function,
   message)`` tuple, where:

   * ``lineno`` is the number of the line on which the string was found,
   * ``function`` is the name of the ``gettext`` function used (if the
     string was extracted from embedded Python code), and
   *   ``message`` is the string, or a tuple of strings for functions
        with multiple string arguments.

   This extraction function operates on the AST and is because of that unable
   to extract any comments.  For comment support you have to use the babel
   extraction interface or extract comments yourself.


.. py:function:: babel_extract(fileobj: BinaryIO, keywords: Sequence[str], comment_tags: Sequence[str], options: Dict[str, Any]) -> Iterator[Tuple[int, str, Union[Optional[str], Tuple[Optional[str], Ellipsis]], List[str]]]

   Babel extraction method for Jinja templates.

   .. versionchanged:: 2.3
      Basic support for translation comments was added.  If `comment_tags`
      is now set to a list of keywords for extraction, the extractor will
      try to find the best preceding comment that begins with one of the
      keywords.  For best results, make sure to not have more than one
      gettext call in one line of code and the matching comment in the
      same line or the line before.

   .. versionchanged:: 2.5.1
      The `newstyle_gettext` flag can be set to `True` to enable newstyle
      gettext calls.

   .. versionchanged:: 2.7
      A `silent` option can now be provided.  If set to `False` template
      syntax errors are propagated instead of being ignored.

   :param fileobj: the file-like object the messages should be extracted from
   :param keywords: a list of keywords (i.e. function names) that should be
                    recognized as translation functions
   :param comment_tags: a list of translator tags to search for and include
                        in the results.
   :param options: a dictionary of additional options (optional)
   :return: an iterator over ``(lineno, funcname, message, comments)`` tuples.
            (comments will be empty currently)


.. py:data:: i18n

.. py:data:: do

.. py:data:: loopcontrols

.. py:data:: debug

