jinja2.idtracking
=================

.. py:module:: jinja2.idtracking


Attributes
----------

.. autoapisummary::

   jinja2.idtracking.VAR_LOAD_PARAMETER
   jinja2.idtracking.VAR_LOAD_RESOLVE
   jinja2.idtracking.VAR_LOAD_ALIAS
   jinja2.idtracking.VAR_LOAD_UNDEFINED


Classes
-------

.. autoapisummary::

   jinja2.idtracking.Symbols
   jinja2.idtracking.RootVisitor
   jinja2.idtracking.FrameSymbolVisitor


Functions
---------

.. autoapisummary::

   jinja2.idtracking.find_symbols
   jinja2.idtracking.symbols_for_node


Module Contents
---------------

.. py:data:: VAR_LOAD_PARAMETER
   :value: 'param'


.. py:data:: VAR_LOAD_RESOLVE
   :value: 'resolve'


.. py:data:: VAR_LOAD_ALIAS
   :value: 'alias'


.. py:data:: VAR_LOAD_UNDEFINED
   :value: 'undefined'


.. py:function:: find_symbols(nodes: Iterable[find_symbols.nodes], parent_symbols: Optional[Symbols] = None) -> Symbols

.. py:function:: symbols_for_node(node: jinja2.nodes.Node, parent_symbols: Optional[Symbols] = None) -> Symbols

.. py:class:: Symbols(parent: Optional[Symbols] = None, level: Optional[int] = None)

   .. py:attribute:: level
      :type:  int
      :value: None



   .. py:attribute:: parent
      :value: None



   .. py:attribute:: refs
      :type:  Dict[str, str]


   .. py:attribute:: loads
      :type:  Dict[str, Any]


   .. py:attribute:: stores
      :type:  Set[str]


   .. py:method:: analyze_node(node: jinja2.nodes.Node, **kwargs: Any) -> None


   .. py:method:: find_load(target: str) -> Optional[Any]


   .. py:method:: find_ref(name: str) -> Optional[str]


   .. py:method:: ref(name: str) -> str


   .. py:method:: copy() -> typing_extensions.Self


   .. py:method:: store(name: str) -> None


   .. py:method:: declare_parameter(name: str) -> str


   .. py:method:: load(name: str) -> None


   .. py:method:: branch_update(branch_symbols: Sequence[Symbols]) -> None


   .. py:method:: dump_stores() -> Dict[str, str]


   .. py:method:: dump_param_targets() -> Set[str]


.. py:class:: RootVisitor(symbols: Symbols)

   Bases: :py:obj:`jinja2.visitor.NodeVisitor`


   Walks the abstract syntax tree and call visitor functions for every
   node found.  The visitor functions may return values which will be
   forwarded by the `visit` method.

   Per default the visitor functions for the nodes are ``'visit_'`` +
   class name of the node.  So a `TryFinally` node visit function would
   be `visit_TryFinally`.  This behavior can be changed by overriding
   the `get_visitor` function.  If no visitor function exists for a node
   (return value `None`) the `generic_visit` visitor is used instead.


   .. py:attribute:: sym_visitor


   .. py:attribute:: visit_Template


   .. py:attribute:: visit_Block


   .. py:attribute:: visit_Macro


   .. py:attribute:: visit_FilterBlock


   .. py:attribute:: visit_Scope


   .. py:attribute:: visit_If


   .. py:attribute:: visit_ScopedEvalContextModifier


   .. py:method:: visit_AssignBlock(node: jinja2.nodes.AssignBlock, **kwargs: Any) -> None


   .. py:method:: visit_CallBlock(node: jinja2.nodes.CallBlock, **kwargs: Any) -> None


   .. py:method:: visit_OverlayScope(node: jinja2.nodes.OverlayScope, **kwargs: Any) -> None


   .. py:method:: visit_For(node: jinja2.nodes.For, for_branch: str = 'body', **kwargs: Any) -> None


   .. py:method:: visit_With(node: jinja2.nodes.With, **kwargs: Any) -> None


   .. py:method:: generic_visit(node: jinja2.nodes.Node, *args: Any, **kwargs: Any) -> None
      :abstractmethod:


      Called if no explicit visitor function exists for a node.



.. py:class:: FrameSymbolVisitor(symbols: Symbols)

   Bases: :py:obj:`jinja2.visitor.NodeVisitor`


   A visitor for `Frame.inspect`.


   .. py:attribute:: symbols


   .. py:method:: visit_Name(node: jinja2.nodes.Name, store_as_param: bool = False, **kwargs: Any) -> None

      All assignments to names go through this function.



   .. py:method:: visit_NSRef(node: jinja2.nodes.NSRef, **kwargs: Any) -> None


   .. py:method:: visit_If(node: jinja2.nodes.If, **kwargs: Any) -> None


   .. py:method:: visit_Macro(node: jinja2.nodes.Macro, **kwargs: Any) -> None


   .. py:method:: visit_Import(node: jinja2.nodes.Import, **kwargs: Any) -> None


   .. py:method:: visit_FromImport(node: jinja2.nodes.FromImport, **kwargs: Any) -> None


   .. py:method:: visit_Assign(node: jinja2.nodes.Assign, **kwargs: Any) -> None

      Visit assignments in the correct order.



   .. py:method:: visit_For(node: jinja2.nodes.For, **kwargs: Any) -> None

      Visiting stops at for blocks.  However the block sequence
      is visited as part of the outer scope.



   .. py:method:: visit_CallBlock(node: jinja2.nodes.CallBlock, **kwargs: Any) -> None


   .. py:method:: visit_FilterBlock(node: jinja2.nodes.FilterBlock, **kwargs: Any) -> None


   .. py:method:: visit_With(node: jinja2.nodes.With, **kwargs: Any) -> None


   .. py:method:: visit_AssignBlock(node: jinja2.nodes.AssignBlock, **kwargs: Any) -> None

      Stop visiting at block assigns.



   .. py:method:: visit_Scope(node: jinja2.nodes.Scope, **kwargs: Any) -> None

      Stop visiting at scopes.



   .. py:method:: visit_Block(node: jinja2.nodes.Block, **kwargs: Any) -> None

      Stop visiting at blocks.



   .. py:method:: visit_OverlayScope(node: jinja2.nodes.OverlayScope, **kwargs: Any) -> None

      Do not visit into overlay scopes.



