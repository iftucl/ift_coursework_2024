

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wcwidth.wcwidth &mdash; Coursework Two 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Coursework Two
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage_instructions.html">Usage Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture_overview.html">Architecture Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Coursework Two</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">wcwidth.wcwidth</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wcwidth.wcwidth</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is a python implementation of wcwidth() and wcswidth().</span>

<span class="sd">https://github.com/jquast/wcwidth</span>

<span class="sd">from Markus Kuhn&#39;s C code, retrieved from:</span>

<span class="sd">    http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c</span>

<span class="sd">This is an implementation of wcwidth() and wcswidth() (defined in</span>
<span class="sd">IEEE Std 1002.1-2001) for Unicode.</span>

<span class="sd">http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html</span>
<span class="sd">http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html</span>

<span class="sd">In fixed-width output devices, Latin characters all occupy a single</span>
<span class="sd">&quot;cell&quot; position of equal width, whereas ideographic CJK characters</span>
<span class="sd">occupy two such cells. Interoperability between terminal-line</span>
<span class="sd">applications and (teletype-style) character terminals using the</span>
<span class="sd">UTF-8 encoding requires agreement on which character should advance</span>
<span class="sd">the cursor by how many cell positions. No established formal</span>
<span class="sd">standards exist at present on which Unicode character shall occupy</span>
<span class="sd">how many cell positions on character terminals. These routines are</span>
<span class="sd">a first attempt of defining such behavior based on simple rules</span>
<span class="sd">applied to data provided by the Unicode Consortium.</span>

<span class="sd">For some graphical characters, the Unicode standard explicitly</span>
<span class="sd">defines a character-cell width via the definition of the East Asian</span>
<span class="sd">FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.</span>
<span class="sd">In all these cases, there is no ambiguity about which width a</span>
<span class="sd">terminal shall use. For characters in the East Asian Ambiguous (A)</span>
<span class="sd">class, the width choice depends purely on a preference of backward</span>
<span class="sd">compatibility with either historic CJK or Western practice.</span>
<span class="sd">Choosing single-width for these characters is easy to justify as</span>
<span class="sd">the appropriate long-term solution, as the CJK practice of</span>
<span class="sd">displaying these characters as double-width comes from historic</span>
<span class="sd">implementation simplicity (8-bit encoded characters were displayed</span>
<span class="sd">single-width and 16-bit ones double-width, even for Greek,</span>
<span class="sd">Cyrillic, etc.) and not any typographic considerations.</span>

<span class="sd">Much less clear is the choice of width for the Not East Asian</span>
<span class="sd">(Neutral) class. Existing practice does not dictate a width for any</span>
<span class="sd">of these characters. It would nevertheless make sense</span>
<span class="sd">typographically to allocate two character cells to characters such</span>
<span class="sd">as for instance EM SPACE or VOLUME INTEGRAL, which cannot be</span>
<span class="sd">represented adequately with a single-width glyph. The following</span>
<span class="sd">routines at present merely assign a single-cell width to all</span>
<span class="sd">neutral characters, in the interest of simplicity. This is not</span>
<span class="sd">entirely satisfactory and should be reconsidered before</span>
<span class="sd">establishing a formal standard in this area. At the moment, the</span>
<span class="sd">decision which Not East Asian (Neutral) characters should be</span>
<span class="sd">represented by double-width glyphs cannot yet be answered by</span>
<span class="sd">applying a simple rule from the Unicode database content. Setting</span>
<span class="sd">up a proper standard for the behavior of UTF-8 character terminals</span>
<span class="sd">will require a careful analysis not only of each Unicode character,</span>
<span class="sd">but also of each presentation form, something the author of these</span>
<span class="sd">routines has avoided to do so far.</span>

<span class="sd">http://www.unicode.org/unicode/reports/tr11/</span>

<span class="sd">Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">division</span>

<span class="c1"># std imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="c1"># local</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.table_vs16</span><span class="w"> </span><span class="kn">import</span> <span class="n">VS16_NARROW_TO_WIDE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.table_wide</span><span class="w"> </span><span class="kn">import</span> <span class="n">WIDE_EASTASIAN</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.table_zero</span><span class="w"> </span><span class="kn">import</span> <span class="n">ZERO_WIDTH</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.unicode_versions</span><span class="w"> </span><span class="kn">import</span> <span class="n">list_versions</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># std imports</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># lru_cache was added in Python 3.2</span>
    <span class="c1"># 3rd party</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">backports.functools_lru_cache</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>

<span class="c1"># global cache</span>
<span class="n">_PY3</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_bisearch</span><span class="p">(</span><span class="n">ucs</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Auxiliary function for binary search in interval table.</span>

<span class="sd">    :arg int ucs: Ordinal value of unicode character.</span>
<span class="sd">    :arg list table: List of starting and ending ranges of ordinal values,</span>
<span class="sd">        in form of ``[(start, end), ...]``.</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    :returns: 1 if ordinal value ucs is found within lookup table, else 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lbound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ubound</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">ucs</span> <span class="o">&lt;</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">ucs</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">[</span><span class="n">ubound</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">ubound</span> <span class="o">&gt;=</span> <span class="n">lbound</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lbound</span> <span class="o">+</span> <span class="n">ubound</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">ucs</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">lbound</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ucs</span> <span class="o">&lt;</span> <span class="n">table</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">ubound</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="mi">0</span>


<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<div class="viewcode-block" id="wcwidth">
<a class="viewcode-back" href="../../autoapi/wcwidth/wcwidth/index.html#wcwidth.wcwidth.wcwidth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wcwidth</span><span class="p">(</span><span class="n">wc</span><span class="p">,</span> <span class="n">unicode_version</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given one Unicode character, return its printable length on a terminal.</span>

<span class="sd">    :param str wc: A single Unicode character.</span>
<span class="sd">    :param str unicode_version: A Unicode version number, such as</span>
<span class="sd">        ``&#39;6.0.0&#39;``. A list of version levels suported by wcwidth</span>
<span class="sd">        is returned by :func:`list_versions`.</span>

<span class="sd">        Any version string may be specified without error -- the nearest</span>
<span class="sd">        matching version is selected.  When ``latest`` (default), the</span>
<span class="sd">        highest Unicode version level is used.</span>
<span class="sd">    :return: The width, in cells, necessary to display the character of</span>
<span class="sd">        Unicode string character, ``wc``.  Returns 0 if the ``wc`` argument has</span>
<span class="sd">        no printable effect on a terminal (such as NUL &#39;\0&#39;), -1 if ``wc`` is</span>
<span class="sd">        not printable, or has an indeterminate effect on the terminal, such as</span>
<span class="sd">        a control character.  Otherwise, the number of column positions the</span>
<span class="sd">        character occupies on a graphic terminal (1 or 2) is returned.</span>
<span class="sd">    :rtype: int</span>

<span class="sd">    See :ref:`Specification` for details of cell measurement.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ucs</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">wc</span><span class="p">)</span> <span class="k">if</span> <span class="n">wc</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="c1"># small optimization: early return of 1 for printable ASCII, this provides</span>
    <span class="c1"># approximately 40% performance improvement for mostly-ascii documents, with</span>
    <span class="c1"># less than 1% impact to others.</span>
    <span class="k">if</span> <span class="mi">32</span> <span class="o">&lt;=</span> <span class="n">ucs</span> <span class="o">&lt;</span> <span class="mh">0x7F</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="c1"># C0/C1 control characters are -1 for compatibility with POSIX-like calls</span>
    <span class="k">if</span> <span class="n">ucs</span> <span class="ow">and</span> <span class="n">ucs</span> <span class="o">&lt;</span> <span class="mi">32</span> <span class="ow">or</span> <span class="mh">0x07F</span> <span class="o">&lt;=</span> <span class="n">ucs</span> <span class="o">&lt;</span> <span class="mh">0x0A0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">_unicode_version</span> <span class="o">=</span> <span class="n">_wcmatch_version</span><span class="p">(</span><span class="n">unicode_version</span><span class="p">)</span>

    <span class="c1"># Zero width</span>
    <span class="k">if</span> <span class="n">_bisearch</span><span class="p">(</span><span class="n">ucs</span><span class="p">,</span> <span class="n">ZERO_WIDTH</span><span class="p">[</span><span class="n">_unicode_version</span><span class="p">]):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># 1 or 2 width</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">_bisearch</span><span class="p">(</span><span class="n">ucs</span><span class="p">,</span> <span class="n">WIDE_EASTASIAN</span><span class="p">[</span><span class="n">_unicode_version</span><span class="p">])</span></div>



<div class="viewcode-block" id="wcswidth">
<a class="viewcode-back" href="../../autoapi/wcwidth/wcwidth/index.html#wcwidth.wcwidth.wcswidth">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wcswidth</span><span class="p">(</span><span class="n">pwcs</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unicode_version</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a unicode string, return its printable length on a terminal.</span>

<span class="sd">    :param str pwcs: Measure width of given unicode string.</span>
<span class="sd">    :param int n: When ``n`` is None (default), return the length of the entire</span>
<span class="sd">        string, otherwise only the first ``n`` characters are measured. This</span>
<span class="sd">        argument exists only for compatibility with the C POSIX function</span>
<span class="sd">        signature. It is suggested instead to use python&#39;s string slicing</span>
<span class="sd">        capability, ``wcswidth(pwcs[:n])``</span>
<span class="sd">    :param str unicode_version: An explicit definition of the unicode version</span>
<span class="sd">        level to use for determination, may be ``auto`` (default), which uses</span>
<span class="sd">        the Environment Variable, ``UNICODE_VERSION`` if defined, or the latest</span>
<span class="sd">        available unicode version, otherwise.</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    :returns: The width, in cells, needed to display the first ``n`` characters</span>
<span class="sd">        of the unicode string ``pwcs``.  Returns ``-1`` for C0 and C1 control</span>
<span class="sd">        characters!</span>

<span class="sd">    See :ref:`Specification` for details of cell measurement.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># this &#39;n&#39; argument is a holdover for POSIX function</span>
    <span class="n">_unicode_version</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pwcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">n</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">last_measured_char</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">pwcs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\u200D</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="c1"># Zero Width Joiner, do not measure this or next character</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\uFE0F</span><span class="s2">&quot;</span> <span class="ow">and</span> <span class="n">last_measured_char</span><span class="p">:</span>
            <span class="c1"># on variation selector 16 (VS16) following another character,</span>
            <span class="c1"># conditionally add &#39;1&#39; to the measured width if that character is</span>
            <span class="c1"># known to be converted from narrow to wide by the VS16 character.</span>
            <span class="k">if</span> <span class="n">_unicode_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_unicode_version</span> <span class="o">=</span> <span class="n">_wcversion_value</span><span class="p">(</span><span class="n">_wcmatch_version</span><span class="p">(</span><span class="n">unicode_version</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">_unicode_version</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">width</span> <span class="o">+=</span> <span class="n">_bisearch</span><span class="p">(</span>
                    <span class="nb">ord</span><span class="p">(</span><span class="n">last_measured_char</span><span class="p">),</span> <span class="n">VS16_NARROW_TO_WIDE</span><span class="p">[</span><span class="s2">&quot;9.0.0&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">last_measured_char</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="c1"># measure character at current index</span>
        <span class="n">wcw</span> <span class="o">=</span> <span class="n">wcwidth</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">unicode_version</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wcw</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># early return -1 on C0 and C1 control characters</span>
            <span class="k">return</span> <span class="n">wcw</span>
        <span class="k">if</span> <span class="n">wcw</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># track last character measured to contain a cell, so that</span>
            <span class="c1"># subsequent VS-16 modifiers may be understood</span>
            <span class="n">last_measured_char</span> <span class="o">=</span> <span class="n">char</span>
        <span class="n">width</span> <span class="o">+=</span> <span class="n">wcw</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">width</span></div>



<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_wcversion_value</span><span class="p">(</span><span class="n">ver_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integer-mapped value of given dotted version string.</span>

<span class="sd">    :param str ver_string: Unicode version string, of form ``n.n.n``.</span>
<span class="sd">    :rtype: tuple(int)</span>
<span class="sd">    :returns: tuple of digit tuples, ``tuple(int, [...])``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="p">(</span><span class="n">ver_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">retval</span>


<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_wcmatch_version</span><span class="p">(</span><span class="n">given_version</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return nearest matching supported Unicode version level.</span>

<span class="sd">    If an exact match is not determined, the nearest lowest version level is</span>
<span class="sd">    returned after a warning is emitted.  For example, given supported levels</span>
<span class="sd">    ``4.1.0`` and ``5.0.0``, and a version string of ``4.9.9``, then ``4.1.0``</span>
<span class="sd">    is selected and returned:</span>

<span class="sd">    &gt;&gt;&gt; _wcmatch_version(&#39;4.9.9&#39;)</span>
<span class="sd">    &#39;4.1.0&#39;</span>
<span class="sd">    &gt;&gt;&gt; _wcmatch_version(&#39;8.0&#39;)</span>
<span class="sd">    &#39;8.0.0&#39;</span>
<span class="sd">    &gt;&gt;&gt; _wcmatch_version(&#39;1&#39;)</span>
<span class="sd">    &#39;4.1.0&#39;</span>

<span class="sd">    :param str given_version: given version for compare, may be ``auto``</span>
<span class="sd">        (default), to select Unicode Version from Environment Variable,</span>
<span class="sd">        ``UNICODE_VERSION``. If the environment variable is not set, then the</span>
<span class="sd">        latest is used.</span>
<span class="sd">    :rtype: str</span>
<span class="sd">    :returns: unicode string, or non-unicode ``str`` type for python 2</span>
<span class="sd">        when given ``version`` is also type ``str``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Design note: the choice to return the same type that is given certainly</span>
    <span class="c1"># complicates it for python 2 str-type, but allows us to define an api that</span>
    <span class="c1"># uses &#39;string-type&#39; for unicode version level definitions, so all of our</span>
    <span class="c1"># example code works with all versions of python.</span>
    <span class="c1">#</span>
    <span class="c1"># That, along with the string-to-numeric and comparisons of earliest,</span>
    <span class="c1"># latest, matching, or nearest, greatly complicates this function.</span>
    <span class="c1"># Performance is somewhat curbed by memoization.</span>
    <span class="n">_return_str</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">_PY3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">given_version</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_return_str</span><span class="p">:</span>
        <span class="c1"># avoid list-comprehension to work around a coverage issue:</span>
        <span class="c1"># https://github.com/nedbat/coveragepy/issues/753</span>
        <span class="n">unicode_versions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">ucs</span><span class="p">:</span> <span class="n">ucs</span><span class="o">.</span><span class="n">encode</span><span class="p">(),</span> <span class="n">list_versions</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unicode_versions</span> <span class="o">=</span> <span class="n">list_versions</span><span class="p">()</span>
    <span class="n">latest_version</span> <span class="o">=</span> <span class="n">unicode_versions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">given_version</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">):</span>
        <span class="n">given_version</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;UNICODE_VERSION&quot;</span><span class="p">,</span> <span class="s2">&quot;latest&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_return_str</span> <span class="k">else</span> <span class="n">latest_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">given_version</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;latest&quot;</span><span class="p">,</span> <span class="s2">&quot;latest&quot;</span><span class="p">):</span>
        <span class="c1"># default match, when given as &#39;latest&#39;, use the most latest unicode</span>
        <span class="c1"># version specification level supported.</span>
        <span class="k">return</span> <span class="n">latest_version</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_return_str</span> <span class="k">else</span> <span class="n">latest_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">given_version</span> <span class="ow">in</span> <span class="n">unicode_versions</span><span class="p">:</span>
        <span class="c1"># exact match, downstream has specified an explicit matching version</span>
        <span class="c1"># matching any value of list_versions().</span>
        <span class="k">return</span> <span class="n">given_version</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_return_str</span> <span class="k">else</span> <span class="n">given_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="c1"># The user&#39;s version is not supported by ours. We return the newest unicode</span>
    <span class="c1"># version level that we support below their given value.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cmp_given</span> <span class="o">=</span> <span class="n">_wcversion_value</span><span class="p">(</span><span class="n">given_version</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># submitted value raises ValueError in int(), warn and use latest.</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;UNICODE_VERSION value, </span><span class="si">{given_version!r}</span><span class="s2">, is invalid. &quot;</span>
            <span class="s2">&quot;Value should be in form of `integer[.]+&#39;, the latest &quot;</span>
            <span class="s2">&quot;supported unicode version </span><span class="si">{latest_version!r}</span><span class="s2"> has been &quot;</span>
            <span class="s2">&quot;inferred.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">given_version</span><span class="o">=</span><span class="n">given_version</span><span class="p">,</span> <span class="n">latest_version</span><span class="o">=</span><span class="n">latest_version</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">latest_version</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_return_str</span> <span class="k">else</span> <span class="n">latest_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="c1"># given version is less than any available version, return earliest</span>
    <span class="c1"># version.</span>
    <span class="n">earliest_version</span> <span class="o">=</span> <span class="n">unicode_versions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cmp_earliest_version</span> <span class="o">=</span> <span class="n">_wcversion_value</span><span class="p">(</span><span class="n">earliest_version</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cmp_given</span> <span class="o">&lt;=</span> <span class="n">cmp_earliest_version</span><span class="p">:</span>
        <span class="c1"># this probably isn&#39;t what you wanted, the oldest wcwidth.c you will</span>
        <span class="c1"># find in the wild is likely version 5 or 6, which we both support,</span>
        <span class="c1"># but it&#39;s better than not saying anything at all.</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;UNICODE_VERSION value, </span><span class="si">{given_version!r}</span><span class="s2">, is lower &quot;</span>
            <span class="s2">&quot;than any available unicode version. Returning lowest &quot;</span>
            <span class="s2">&quot;version level, </span><span class="si">{earliest_version!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">given_version</span><span class="o">=</span><span class="n">given_version</span><span class="p">,</span> <span class="n">earliest_version</span><span class="o">=</span><span class="n">earliest_version</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">earliest_version</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_return_str</span> <span class="k">else</span> <span class="n">earliest_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

    <span class="c1"># create list of versions which are less than our equal to given version,</span>
    <span class="c1"># and return the tail value, which is the highest level we may support,</span>
    <span class="c1"># or the latest value we support, when completely unmatched or higher</span>
    <span class="c1"># than any supported version.</span>
    <span class="c1">#</span>
    <span class="c1"># function will never complete, always returns.</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">unicode_version</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unicode_versions</span><span class="p">):</span>
        <span class="c1"># look ahead to next value</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cmp_next_version</span> <span class="o">=</span> <span class="n">_wcversion_value</span><span class="p">(</span><span class="n">unicode_versions</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># at end of list, return latest version</span>
            <span class="k">return</span> <span class="n">latest_version</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_return_str</span> <span class="k">else</span> <span class="n">latest_version</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="c1"># Maybe our given version has less parts, as in tuple(8, 0), than the</span>
        <span class="c1"># next compare version tuple(8, 0, 0). Test for an exact match by</span>
        <span class="c1"># comparison of only the leading dotted piece(s): (8, 0) == (8, 0).</span>
        <span class="k">if</span> <span class="n">cmp_given</span> <span class="o">==</span> <span class="n">cmp_next_version</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">cmp_given</span><span class="p">)]:</span>
            <span class="k">return</span> <span class="n">unicode_versions</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Or, if any next value is greater than our given support level</span>
        <span class="c1"># version, return the current value in index.  Even though it must</span>
        <span class="c1"># be less than the given value, its our closest possible match. That</span>
        <span class="c1"># is, 4.1 is returned for given 4.9.9, where 4.1 and 5.0 are available.</span>
        <span class="k">if</span> <span class="n">cmp_next_version</span> <span class="o">&gt;</span> <span class="n">cmp_given</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unicode_version</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span>
        <span class="s2">&quot;Code path unreachable&quot;</span><span class="p">,</span>
        <span class="n">given_version</span><span class="p">,</span>
        <span class="n">unicode_versions</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># pragma: no cover</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>